<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tom Preston-Werner</title>
 <link href="http://tom.preston-werner.com/atom.xml" rel="self"/>
 <link href="http://tom.preston-werner.com/"/>
 <updated>2013-07-04T19:20:01+08:00</updated>
 <id>http://tom.preston-werner.com/</id>
 <author>
   <name>Tom Preston-Werner</name>
   <email>tom@mojombo.com</email>
 </author>

 
 <entry>
   <title>osx下编译so的困难记录</title>
   <link href="http://tom.preston-werner.com/2013/07/04/g%2B%2B-things2.html"/>
   <updated>2013-07-04T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/07/04/g++-things2</id>
   <content type="html">&lt;p&gt;昨天一度以为那个模块编好了就一劳永逸了，结果今天早上到了之后又悲剧的发现还有另外一个东西要编译，sigh，为了工作正常展开，为了不倒退到ubuntu时代，只能上了。&lt;/p&gt;

&lt;p&gt;首先遇到的问题是一个文件中用了SOCK_NONBLOCKING，翻了一下socket的manual, 发现果然没有（当时狗眼瞎了，没有看到赫然印着的&lt;font color=&quot;red&quot;&gt;BSD system calls manual&lt;/font&gt;）, 还在傻乎乎的想，是不是我g++版本的问题，导致没有这个东东呢。。。捂脸。。。&lt;br/&gt;
正如网页&lt;a href=&quot;http://www.gnu.org/software/libc/&quot;&gt;gnu c library&lt;/a&gt;上说的那样，unix-like 系列的操作系统都需要一个定义了系统调用和其他如open，malloc之类基础设施的c语言库，在mac里，被放在了/usr/lib/system中。回忆一下系统库和标准c库之间的不同，省的再次头昏脑涨。&lt;br/&gt;
至于为什么没有SOCK_NONBLOCK，跟内核有关，我大mac党躺枪....最后删了一些代码了事(我这边用不到那些)&lt;/p&gt;

&lt;p&gt;随后遇到的问题是&lt;code&gt;mach-o, but wrong architecture&lt;/code&gt;，是模块编译成功后dlopen该模块产生了问题，解决这个问题饶了一些弯子。&lt;br/&gt;
首先隆重介绍工具lipo, 这个是用来生成或者操作universal文件的，所谓universal文件就是multi-architecture文件,于是。。。我用它来查看架构。。。经过检查发现python的arch和要用库的都是x86_64，于是开始检查python, &lt;code&gt;defaults read com.apple.versioner.python&lt;/code&gt; 能够检查当前版本python的默认架构, 发现是坑爹的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;Prefer-32-Bit&quot; = 1;
    &quot;Prefer-64-Bit&quot; = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;难怪会有&lt;code&gt;wrong architecture&lt;/code&gt;的问题，改之，然后就能正确的运行了。顺手查了一下dlopen(), 里面提到&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;dlopen() can load dynamic libraries and bundles.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这就跟上一篇文章里面的说法不太一致了，这个事儿还是留时间做做实验吧.&lt;/p&gt;

&lt;p&gt;还有一个遗留问题，晚上查吧&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>osx下编译dylib的知识记录</title>
   <link href="http://tom.preston-werner.com/2013/07/03/g%2B%2B-things.html"/>
   <updated>2013-07-03T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/07/03/g++-things</id>
   <content type="html">&lt;p&gt;上午开个大半个上午的会&lt;br/&gt;
下午本想针对要做的事儿写出个初步的模型来，结果光是环境就折腾了大半天，万恶的移植
遇到的问题主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;g++中的-std指令中用到的几个参数有什么不同？发现std::stoi这个函数还有std::to_string()这个函数是不存在的，跟那些参数有关吗？还是跟平台有关？&lt;br/&gt;
是不同的c++标准，i686-apple-darwin11-llvm-g++-4.2 (GCC) 4.2.1的stdlib里没提供这两个函数，暂时不想研究&lt;/li&gt;
&lt;li&gt;&lt;p&gt;osx中的g++的库文件跟linux有什么不同，发现找了半天没找到的一个so文件被我改成dylib文件就成了，还有其他不同的地方吗？&lt;br/&gt;
找到了&lt;a href=&quot;http://docstore.mik.ua/orelly/unix3/mac/ch05_03.htm&quot;&gt;一篇不错的文&lt;/a&gt;，虽然有点一知半解，大致了解了linux体系中的二进制文件采用的是ELF格式，而mac中采用的是Match-O格式。在elf格式中，shared libraries 和 loadable module是一样的。但是在Match-O体系中，这两个东西是有着严格区别的。&lt;br/&gt;
前者用otool显示出来的类型是DYLIB，后缀是dylib，只能静态链接，如果用dyld API的话可以动态加载。  * 后者叫做bundles，虽然mac推荐用.bundle的后缀，无奈linux党太强大了，还是缀以了so。在mac中bundle只能动态加载和反加载（也要用dyld），不能链接。
然后就是一大堆例子了。。。感觉mac下的东西很难用的样子。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还有就是boost的具体功能是什么，与stl的异同在哪里？另外就是几个不明所以的库，libev和libevent？估计查查manual就可以了
boost 就是一组功能性的程序库，广泛采用template实现，也许这是跟stl唯一的相同点吧。。。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;libev是Marc Lehmann用C写的高性能事件循环库。通过libev，可以灵活地把各种事件组织管理起来，如：时钟、io、信号等。libev在业界内也是广受好评，不少项目都采用它来做底层的事件循环。
libevent是一个异步事件处理软件函式库，以BSD许可证发布。&lt;br/&gt;
libevent提供了一组应用程序编程接口（API），让程式设计师可以设定某些事件发生时所执行的函式，也就是说，libevent可以用来取代网络服务器所使用的事件循环检查框架。&lt;br/&gt;
由于可以省去对网络的处理，且拥有不错的效能，有些软件使用libevent作为网络底层的函式库，如：memcached、Tor。&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt; 好吧，模型的事儿就明早折腾吧，最基础的设施刚刚搭建起来，还不确定能不能用......&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>日参省乎己-07-22</title>
   <link href="http://tom.preston-werner.com/2013/07/02/self-thinking.html"/>
   <updated>2013-07-02T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/07/02/self-thinking</id>
   <content type="html">&lt;p&gt;刚刚洗澡的时候突然想到了近两天闲暇时光的所作所为&lt;br/&gt;
往往是阳光烂漫的上午或者是昏昏欲睡的午后，红茶一杯，转椅一柄，关键词二三，然后就是漫无目的的扫荡相关的技术文章。&lt;br/&gt;
这样其实是不对滴， 原因有下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;效率低下。漫无目标，扫荡了一遍估计大部分也在扫荡结束的时候忘记了，虽然现在有写博客记录的习惯了，但是盯着一个妹子泡和满大街瞄然后号称我要泡妹子哪个效率高一目了然。&lt;/li&gt;
&lt;li&gt;容易分散精力，文章里面可以分散精力的东西太多了，这边还在研究java的classloader，那边很容易就被“jvm上的十大未来语言”吸引住了眼球。&lt;/li&gt;
&lt;li&gt;没成就感。。。漫无目的的扫荡鸟问题都解决不了。这个是最主要的问题。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以以后还是要多多的抱着解决某个实际问题的想法去学习，这样效率，精力和成就感上都有保证，而且会更有利于时间管理吧。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>java里的classloader</title>
   <link href="http://tom.preston-werner.com/2013/07/02/classloader.html"/>
   <updated>2013-07-02T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/07/02/classloader</id>
   <content type="html">&lt;h1&gt;java的classloader&lt;/h1&gt;

&lt;h2&gt;基本概念&lt;/h2&gt;

&lt;p&gt;java的classloader的作用是动态的将class载入jvm&lt;br/&gt;
jvm运行的时候，用到了三个classloader:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bootstrap classloader  ---用来加载java最核心的class，需要加载的class在jre/lib中，bootstrap是在jvm中的，所以写java代码的时候我们是看不到的，通过-Xbootclasspath可以指定加载哪些core api&lt;/li&gt;
&lt;li&gt;extension classloader   ---加载标准拓展库的classloader, 需要加载的类在jre/lib/ext中&lt;/li&gt;
&lt;li&gt;sys classloader ---从环境变量配置的classpath中来查找路径，设置classpath即可&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Class.getClassLoader()会得到当前类的classloader，如果该类是String之类的class， 那么加载它的classloader就是bootstrap classloader， 如果是classpath中的包，那么会得到system classloader, ext classloader 也一样&lt;br/&gt;
  ##parent delegation
  classloader 加载类的时候会采用双亲委托的模型。在当前classloader需要加载一个类的时候，先委托其parent去加载这个类，如果parent找不到这个类，自己才开始加载。这里的parent并不是superclass， 而是一个引用关系，也就是按照上面提到的那个顺序。&lt;br/&gt;
  这样做的好处就是提升安全性，比如你自己实现的String就不会被加载到jvm中，因为首先会加载的是core api中的class。&lt;br/&gt;
  ##class1 == class2 ?
  在比较两个class是否相等的时候，不仅比较两个class的名字是否相等，还要比较加载两个class的是否为同一classloader，只有两个条件同时满足的时候，才会认为两个class是等价的，否则就会出现转型错误&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;  当当当当，以上是大致的概念，不过都没有提到configuration里面用到的contextclassloader&lt;br/&gt;
  不过解释还是有点难懂，估计短时间内也用不着，先放着吧&lt;br/&gt;
  留下一个链接，日后慢慢研究 &lt;a href=&quot;http://www.javaworld.com/javaworld/javaqa/2003-06/01-qa-0606-load.html&quot;&gt;find a way out of the classloader maze&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>dataFu印象</title>
   <link href="http://tom.preston-werner.com/2013/07/01/datafu.html"/>
   <updated>2013-07-01T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/07/01/datafu</id>
   <content type="html">&lt;p&gt;datafu是linkedin（虽然我现在还没用过。。。）内部用到的一个pig udf的集合，稳定，经过良好的测试。&lt;br/&gt;
主要用于大规模数据挖掘和数据统计。&lt;br/&gt;
好吧，以上是官方说法，我花了一点时间扫了一下里面的udf（&lt;a href=&quot;http://linkedin.github.io/datafu/docs/javadoc/&quot;&gt;javadoc在这里&lt;/a&gt;，里面的东西好少），用途最大的大约是datafu.pig.bags包和datafu.pig.bags.sets里面的函数了，前者是针对bag类型的一些常见操作，后者弥补了pig中没有set操作的缺陷，虽然只有intersetc和union两个函数&lt;/p&gt;

&lt;p&gt;剩下的包里面大约是我这辈子都不会用到的一些函数了，pagerank，haversinedist,不过应该能拿来做一些好玩儿的事情&lt;/p&gt;

&lt;p&gt;  顺便翻了一下里面的源码，util里面有些不错的东东&lt;br/&gt;
  目测比较实用的有SimpleEvalFunc,　实现pig udf的exec要从Tuple arg0里面提取参数并转型，这样就涉及到类型检查之类的操作（实际上从来没做过类型检查= =， 但是吃过这方面的亏），这个函数把这一些检查操作进行了封装，只需要实现call函数，就会自动完成一些列的操作。&lt;/p&gt;

&lt;p&gt;  另外工具包里的代码都有着良好的实现，构造函数和outputSchema函数一应俱全，exception更是给的恰到好处，更是包含了平时不可能用到的Accumulator的实现，对于刚开始学习pig的人写udf应该会带来很大帮助。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jpype的一些事儿</title>
   <link href="http://tom.preston-werner.com/2013/06/22/introduction-to-jpype.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/06/22/introduction-to-jpype</id>
   <content type="html">&lt;h1&gt;Jpype的一些事儿&lt;/h1&gt;

&lt;p&gt;Jpype提供了python访问java代码的能力，但是实现上不同于Jython语言（没错，这货是门语言），Jpype只是一个库。&lt;br/&gt;
由于有一个移植小工具的需求，于是就用到了Jpype，琢磨了一番之后，深感方便。下面就简单的讲讲&lt;/p&gt;

&lt;h2&gt;how to use ?&lt;/h2&gt;

&lt;p&gt;首先当然是安装啦，从&lt;a href=&quot;http://jpype.sourceforge.net&quot;&gt;官网&lt;/a&gt;上下载， 解压，然后就。。。当当当当！可以用了！&lt;/p&gt;

&lt;h4&gt;start a jvm&lt;/h4&gt;

&lt;p&gt;Jpype的核心包是jpype， jpype是从jvm的native层进行调用的，首先要做的操作是打开jvm虚拟机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from jpype import *

jvmPath = getDefaultJVMPath()

startJVM(jvmPath)
shutdownJVM()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   这里的jvmPath是能够自己设置的, getDefaultJVMPath()给出的只是当前系统下默认的jvmpath, 以os x为例， 可以看到给出的默认getDefaultJVMPath()函数是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def getDefaultJVMPath() :
# on darwin, the JVM is always in the same location it seems ...
return '/System/Library/Frameworks/JavaVM.framework/JavaVM'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  没错，我要讲的就是那句贱贱的注释传达的意思，至于linux和window平台，稍微复杂一点，所以自行设置还是比较靠谱的&lt;br/&gt;
  只是开关虚拟机当然没什么意思了，而且我们用Jpype的目的并不是&quot;hello, world&quot;,所以我们直接跳过hello world的步骤，直接开始学着调用你自己的java代码&lt;/p&gt;

&lt;h4&gt;call your java code&lt;/h4&gt;

&lt;p&gt;   你有两种方式放置你要调用的java代码，直接编译，把所有的东西放在一个文件夹里，或者使用一个jar包，总之这个自己来控制吧。下面直接假设你所有的东西都在一个叫temp.jar的java的jar包里了&lt;br/&gt;
   Jpype比较弱的一点是要你自己指定classpath, 我们假设temp.jar就在当前的文件夹下，于是classpath肯定会是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   然后我们就可以打开虚拟机了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from Jpype import *

ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
startJVM(getDefaultJVMPath(), &quot;-Djava.classpath.path=&quot;+ext_classpath)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   下面做一个假设&lt;/p&gt;

&lt;p&gt;   这个temp.jar中有一个你想要的调用的class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package trial.jpype;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import trial.jpype.CoreDataType.NameComponents;


import trial.on.jpype.shuaizki;

import me.shuaizki.util.IO.MyIO;

public class namenormalizer {

public static void speak1()
{
    System.out.println(&quot;blah..blah..blah&quot;);
}

public static String getNormalizedName(String str)
{
    NameComponents nc = NameSplit.getSingleton().getNormalizedName(str);
    return ncToJson(nc);
}

public static String ncToJson(NameComponents nc)
{
    String ret = &quot;{&quot;;
    return ret;
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想调用的是namenormalizer中的getNormalizedName和speak1，首先要获取namenormalizer这个class，有两种途径获取这个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namenormalizer = JClass('trial.jpype.namenormalizer')
利用
ns = namenormalizer() 获取namenormlaizer 的一个对象
利用ns.getNormalizedName(“hello”)调用或者直接利用 namenormalizer.getNormalizedName()进行调用， 这样就完成了类的获取和函数的调用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种途径是利用Jpackage()这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namenormalizer = JPackage('trial').jpype.namenormalizer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   其实看看源码就会知道jpackage对类的访问依靠的也是jclass，只不过其提供了对包的访问。归根结底能找到类还是要依靠_jpype.findClass()这个函数，也就是C++代码里的东西，这个后面会有介绍。&lt;/p&gt;

&lt;h4&gt;运行代码的注意事项&lt;/h4&gt;

&lt;p&gt;   好了，我们最后的代码长成这个样子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from Jpype import *

ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
startJVM(getDefaultJVMPath(), &quot;-Djava.classpath.path=&quot;+ext_classpath)
namenormalizer = JClass('trial.jpype.namenormalizer')
namenormalizer.getNormalizedName(&quot;hello&quot;)

shuwdownJVM()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   尝试着运行一下吧~&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; namesplit = JClass('trial.jpype.namenormalizer')
 File &quot;/Library/Python/2.7/site-packages/jpype/_jclass.py&quot;, line 54, in JClass
raise _RUNTIMEEXCEPTION.PYEXC(&quot;Class %s not found&quot; % name)
 jpype._jexception.ExceptionPyRaisable: java.lang.Exception: Class
 trial.jpype.namenormalizer not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  纳尼！！！这是什么情况，找不到呢
  看一下我们的代码，发现没什么问题，包也在，那是为什么呢? 如果你用eclipse 的话，打开你的.classpath看看吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;classpath&amp;gt;
    &amp;lt;classpathentry kind=&quot;src&quot; path=&quot;src&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;src&quot; path=&quot;test&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.launching.macosx.MacOSXType/Java SE 6 (MacOS X Default)&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/protobuf-java-2.4.1.jar&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/gson-2.2.4.jar&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;output&quot; path=&quot;bin&quot;/&amp;gt;
&amp;lt;/classpath&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   如果你不用eclipse，肯定自己知道你用了一些外部包了。这些都要统统放在classpath里，不然Jpype自己是找不到的
    把这些lib里的东西都放在classpath里就行了，代码应该就能运行ok了&lt;/p&gt;

&lt;h4&gt;debug建议&lt;/h4&gt;

&lt;p&gt;如果还是跑不起来的话，那就重新编译一下JPype，让他打出debug信息，自己慢慢琢磨一下吧&lt;br/&gt;
打开src/native/common/include/jpype.h这个文件，第23行的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//#define JPYPE_TRACING_INTERNAL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  被注释掉了，将它恢复正常了吧，然后回到Jpype的目录下，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo python setup.py build -f
sudo python setup.py install -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  再运行你的代码的话，就会看到tracing信息了，剩下的就自己慢慢琢磨去吧&lt;/p&gt;

&lt;h2&gt;原理&lt;/h2&gt;

&lt;p&gt;jpype其实用的是jni实现&lt;br/&gt;
JNI就是Java Native Interface, 即可以实现Java调用本地库, 也可以实现C/C++调用Java代码, 从而实现了两种语言的互通, 可以让我们更加灵活的使用。&lt;br/&gt;
之前没听过的同学可以自行学习学习&lt;br/&gt;
利用c++完成对java调用的代码，做成python的库，这就是jpype的全部，实现全在代码里，大家自行参考喽&lt;br/&gt;
后面我会抽时间写写关于jni的博客，顺便解析一下jpype的实现&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>hadoop源码阅读-configuration</title>
   <link href="http://tom.preston-werner.com/2013/06/22/hadoop-configuration.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/06/22/hadoop-configuration</id>
   <content type="html">&lt;h1&gt;configuration&lt;/h1&gt;

&lt;p&gt;实现了Interable&amp;lt;Map.Entry&amp;lt;String, String&gt;&gt;接口和Writable接口&lt;/p&gt;

&lt;h2&gt;私有变量&lt;/h2&gt;

&lt;p&gt;比较关键的私有变量有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;Object&amp;gt; resources; 
记录各个资源文件，configuration里总共有四种形式了  
    String（文件名）， URL, Path(hadoop 自己定义的), 还有inputstream
    在loadresource的时候，用instanceof进行判断然后加载

Set&amp;lt;String&amp;gt; finalParameters; 
    记录了const的哪些配置变量（比如hdfs-site.xml里面的dfs.replication, 被设置成了final）

boolean loadDefaults = true; 用于确定是否加载默认资源(默认加载哦)

private static final WeakHashMap&amp;lt;Configuration,Object&amp;gt; REGISTRY = 
new WeakHashMap&amp;lt;Configuration,Object&amp;gt;(); 各个Conf对象的一个注册表

private static final CopyOnWriteArrayList&amp;lt;String&amp;gt; defaultResources =
new CopyOnWriteArrayList&amp;lt;String&amp;gt;(); 默认资源的一个列表, CopyOnWriteArrayList是线程安全的哦

private boolean storeResource; 是否要存储下面的hashmap

privte HashMap&amp;lt;String, String&amp;gt; updatingResource; 存储某个配置项的来源资源文件

其次是configuration里面的两个个Properties类型的变量,
properties存储所有的配置项目, overlay存储所有被覆盖的配置
还有classloader变量，是当前线程的contextclassloader, 或者是当前类的classloader（如果前者为空的话）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;方法&lt;/h2&gt;

&lt;p&gt;首先用一个静态块加载了&quot;core-default.xml&quot;和&quot;core-site.xml&quot;两个资源文件&lt;/p&gt;

&lt;h3&gt;线程安全&lt;/h3&gt;

&lt;p&gt;由于configuration是线程安全的，因而注意代码里面的同步，有趣的是在configuration的一个构造函数Configuration(Configutaion other)中，看到了这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.resources = (ArrayList)other.resources.clone();
synchronized(other) {
 if (other.properties != null) {
   this.properties = (Properties)other.properties.clone();
 }

 if (other.overlay!=null) {
   this.overlay = (Properties)other.overlay.clone();
 }
}

this.finalParameters = new HashSet&amp;lt;String&amp;gt;(other.finalParameters);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让人困惑的是为什么针对resources和finalParameters的操作并没有被synchronized&lt;/p&gt;

&lt;h3&gt;资源加载相关函数&lt;/h3&gt;

&lt;p&gt;properties并非启动或者生成对象的时候加载的，而是在需要的时候才会加载，因而当有新的资源需要载入的时候，需要一个函数清理当前的properties 和 finalParameters , 这样在需要用到的时候才能重新加载.其实这个函数很简单，设置properties == null ，clear finalParameters就行了&lt;/p&gt;

&lt;h3&gt;get 和 set函数&lt;/h3&gt;

&lt;h4&gt;基本类型和enum&lt;/h4&gt;

&lt;p&gt;各种各样的get和set函数，五花八门，针对各个基本类型
都是针对properties进行操作的，由于Properties这个类本身是线程安全的，因而各种函数都是天然的线程安全函数---除了一个需要特别实现的函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private synchronized Properties getOverlay() {
if (overlay==null){
  overlay=new Properties();
}
return overlay;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }&lt;/p&gt;

&lt;h4&gt;IntegerRangs类和函数&lt;/h4&gt;

&lt;p&gt;将字符串转化为整数区间的类，目前还不清楚具体的作用是什么，只看到了一个isIncluded， 竟然是用遍历所有range来判断是否被包含在内的，感觉相当弱。。。。&lt;br/&gt;
随着这个类提供的是一个getRange函数,获取IntegerRanges结果。
值得注意的是这里的IntegerRangs使用的是静态内部类，有关静态内部类的好处看&lt;a href=&quot;http://book.51cto.com/art/201202/317517.htm&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;get class&lt;/h4&gt;

&lt;p&gt;剩下的get函数就只剩下getclass系列了&lt;br/&gt;
封装的很全面，不过实际上还是调用Class.forName(name, true, classloader)&lt;br/&gt;
有一个不错的实现之前完全没见过，就是载入实现了某个接口的类，函数如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public &amp;lt;U&amp;gt; Class&amp;lt;? extends U&amp;gt; getClass(String name, 
                                     Class&amp;lt;? extends U&amp;gt; defaultValue, 
                                     Class&amp;lt;U&amp;gt; xface) {
try {
  Class&amp;lt;?&amp;gt; theClass = getClass(name, defaultValue);
  if (theClass != null &amp;amp;&amp;amp; !xface.isAssignableFrom(theClass))
    throw new RuntimeException(theClass+&quot; not &quot;+xface.getName());
  else if (theClass != null)
    return theClass.asSubclass(xface);
  else
    return null;
} catch (Exception e) {
  throw new RuntimeException(e);
}
}
运用了isAssignableFrom函数的特性, 判断当前Class是否是theclass the superclass 或者是 superinterface(两个类相等也返回true哦)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;get resouce&lt;/h4&gt;

&lt;p&gt;核心函数是classloader.getResource&lt;/p&gt;

&lt;h4&gt;loadResource&lt;/h4&gt;

&lt;p&gt;对xml的解析用的是javax.xml.parsers&lt;br/&gt;
loadResource(Properties, Object, boolean)
是个递归函数，每次函数被调用，都会对 Element root进行赋值，然后判断root的tagname是否是configuration，如果不是的话会出直接退出，如果是，逐个对root的childnode进行解析&lt;br/&gt;
如果子节点的tag那么是configuration，调用loadresource返回上面那个步骤。否则判断子节点的tagnode是否为property（真麻烦啊。。。不过这样强有力的保障了正确性）， blah…blah…解析子节点并放在properties和finalParmeter里面&lt;/p&gt;

&lt;h5&gt;总体的感觉是封装的很标准，也有很多值得借鉴的实现。不过因为功力不够的缘故，留下了一些疑问：&lt;/h5&gt;

&lt;h5&gt;1、某些为了保证线程安全而加的synchronized段，比如上面提到的那段&lt;/h5&gt;

&lt;h5&gt;2、不同类型的classloader用起来有什么区别，比如configuration里涉及到的两种类型&lt;/h5&gt;

&lt;h5&gt;3、configuration中用到hashCode的两个函数getLocalPath和getFile&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public File getFile(String dirsProp, String path)
  throws IOException {
  String[] dirs = getStrings(dirsProp);
  int hashCode = path.hashCode();
  for (int i = 0; i &amp;lt; dirs.length; i++) {  // try each local dir
    int index = (hashCode+i &amp;amp; Integer.MAX_VALUE) % dirs.length;
    File file = new File(dirs[index], path);
    File dir = file.getParentFile();
    if (dir.exists() || dir.mkdirs()) {
      return file;
    }
  }
  throw new IOException(&quot;No valid local directories in property: &quot;+dirsProp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果之前看看注释的话，这段代码应该会很容易理解了，其实就是dirs里面包含很多项的话，从里面选出一个来，如果满足条件就使用，否则就选下一个。&lt;br/&gt;
hashcode的使用是为了保证随即性。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>博客动起来了</title>
   <link href="http://tom.preston-werner.com/2013/06/13/first-artical.html"/>
   <updated>2013-06-13T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/06/13/first-artical</id>
   <content type="html">&lt;h2&gt;博客动起来了&lt;/h2&gt;

&lt;p&gt;话说终于让博客动起来了。。。时隔产生这个想法n个月之后&lt;br/&gt;
不过庆幸的是这个想法最终没被忘记&lt;br/&gt;
小小得瑟一下自己跟拖延症做斗争的顽强勇气&lt;br/&gt;
以后就在这个上面写东西了, mark一下&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>本月书单</title>
   <link href="http://tom.preston-werner.com/2013/06/05/booklist-of-June.html"/>
   <updated>2013-06-05T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/06/05/booklist-of-June</id>
   <content type="html">&lt;h2&gt;本月书单&lt;/h2&gt;

&lt;p&gt;1、中国国民性演变历程&lt;/p&gt;

&lt;h2&gt;&lt;img src=&quot;http://img5.douban.com/lpic/s26381229.jpg&quot; alt=&quot;中国国民性演变历程&quot; /&gt;&lt;/h2&gt;

&lt;p&gt;2、Hadoop技术内幕-深入解析hadoop common和hdfs架构设计与实现原理&lt;/p&gt;

&lt;h2&gt;&lt;img src=&quot;http://img3.douban.com/lpic/s26376893.jpg&quot; alt=&quot;&quot; /&gt;&lt;/h2&gt;

&lt;p&gt;3、高效能人士的七个习惯&lt;br/&gt;
&lt;img src=&quot;http://img3.douban.com/lpic/s1152683.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>