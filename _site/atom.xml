<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tom Preston-Werner</title>
 <link href="http://tom.preston-werner.com/atom.xml" rel="self"/>
 <link href="http://tom.preston-werner.com/"/>
 <updated>2014-11-03T11:38:53+08:00</updated>
 <id>http://tom.preston-werner.com/</id>
 <author>
   <name>Tom Preston-Werner</name>
   <email>tom@mojombo.com</email>
 </author>

 
 <entry>
   <title>Hamcrest_and_junit</title>
   <link href="http://tom.preston-werner.com/java/2014/11/03/hamcrest_and_junit.html"/>
   <updated>2014-11-03T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/java/2014/11/03/hamcrest_and_junit</id>
   <content type="html">&lt;h1&gt;Junit and Hamcrest&lt;/h1&gt;

&lt;h3&gt;从Hamcrest开始&lt;/h3&gt;

&lt;p&gt;wiki了一下hamcrest和项目的tutorial，发现是个很不错的小框架。&lt;/p&gt;

&lt;p&gt;从历史说起的话，第一代单元测试框架提供了断言表达式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert(x == y) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这样对错误信息很不友好，于是第二代单元测试框架提供了一组测试语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert_equal(x , y)
assert_not_equal(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对测试是友好了，但是测试语句的数量暴涨&lt;/p&gt;

&lt;p&gt;于是第三代单元测试框架就使用如hamcrest的库来支持assert_that的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert_that(x, equals(y))
assert_that(x, is_not(equals(y))) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就能优美的输出错误信息。并且通过组合不同的匹配器，可以获得极大的拓展性。&lt;/p&gt;

&lt;p&gt;匹配器封装了一种匹配操作，可以是简单的equals操作，也可以是原来几种封装器的再封装，譬如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Matcher a = equals(10)
Matcher b = greatThan(0)
Matcher c = allOf(a, b)

Matcher a1 = equals(-20)
Matcher b1 = lessThan(0)
Matcher c1 = allOf(a1, b1)

Matcher d = anyOf(c, c1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a, b, a1, b1 就是比较简单的匹配器，c,c1,d就是通过其他封装器组合而成的。&lt;/p&gt;

&lt;p&gt;我用的junit-4.10.jar已经集成了hamcrest。至于具体是用独立的hamcrest，还是junit集成版的，后面用用看喽。&lt;/p&gt;

&lt;h3&gt;Junit&lt;/h3&gt;

&lt;p&gt;简单的过一遍junit的文档，记录一些自己不熟悉的东西。&lt;/p&gt;

&lt;h4&gt;method order&lt;/h4&gt;

&lt;p&gt;从4.11版本开始，可以指定固定的method顺序了。但是仍然不能指定test执行的顺序。目前只有两种固定顺序。 通过给测试类制定@FixMethodOrder&lt;/p&gt;

&lt;p&gt;@FixMethodOrder(MethodSorters.JVM): 返回jvm给的方法顺序，所以每次跑的顺序可能不一样。&lt;/p&gt;

&lt;p&gt;@FixMethodOrder(MethodSorters.NAME_ASCENDING): Sorts the test methods by method name, in lexicographic order.&lt;/p&gt;

&lt;h4&gt;Rule&lt;/h4&gt;

&lt;p&gt;以前从没用过也不知道Rule这个annonation。 &lt;br/&gt;
Rule是用来为了给一个类中所有的测试增加某种功能的。比如说ExternalResource这个类，如果希望测试类里面的每一个测试都能申请到某数据库连接，然后在测试完之后释放这个连接的话，就可以自己实现一个ExternalResource类来完成。这样就能够不使用Before和After了。&lt;/p&gt;

&lt;p&gt;比较带感的是:&lt;/p&gt;

&lt;p&gt;TemporaryFolder 能够为测试创建临时文件或文件夹，测试函数结束后会删除&lt;/p&gt;

&lt;p&gt;ExternalResource 抽象类，实现了before和after之后，就能在测试函数前后执行这两个函数了&lt;/p&gt;

&lt;p&gt;ErrorCollector 收集throwble，然后完成测试后一次性报告所有的error&lt;/p&gt;

&lt;p&gt;TestWatcher  主要是测试过程记录作用，starting finished功能跟Before After相近，成功的case会进入successed，失败的case会进入failed，还有一个apply函数，暂时不知道是干什么的。&lt;/p&gt;

&lt;p&gt;TimeOutRule  类如其名&lt;/p&gt;

&lt;p&gt;还有就是自定义的了&lt;/p&gt;

&lt;h4&gt;Exception test&lt;/h4&gt;

&lt;p&gt;为了保证程序和预期的那样抛出异常，所以要有异常测试。&lt;/p&gt;

&lt;p&gt;如果是简单的小测试，可以用annotation参数来完成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test(expected= IndexOutOfBoundsException.class) 
public void empty() { 
     new ArrayList&amp;lt;Object&amp;gt;().get(0); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种方法就是用上面提到的Rule, ExpectedException类&lt;/p&gt;

&lt;h4&gt;junit matcher&lt;/h4&gt;

&lt;p&gt;除了junit自带的和hamcrest自带的，还有一些第三方的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Excel spreadsheet matchers&lt;/li&gt;
&lt;li&gt;JSON matchers&lt;/li&gt;
&lt;li&gt;XML/XPath matchers&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;Ignore a test&lt;/h4&gt;

&lt;p&gt;加上ignore annonation就行了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Ignore(&quot;Test is ignored as a demonstration&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;timeout&lt;/h4&gt;

&lt;p&gt;前面讲到Rule的时候有说道，有TimeOut rule，这个是对一个测试类里面的所有test适用的，还有一个对单个test作用的timeout的设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test(timeout=1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;multithread / concurrent test&lt;/h4&gt;

&lt;p&gt;给出一篇文章里面的测试方法, assertConcurrent，来源在&lt;a href=&quot;http://www.planetgeek.ch/2009/08/25/how-to-find-a-concurrency-bug-with-java/&quot;&gt;assertConcurrent&lt;/a&gt;，完整的实现不长，这里可以大致说说实现的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   public static void assertConcurrent(final String message, final List&amp;lt;? extends Runnable&amp;gt; runnables, final int maxTimeoutSeconds) throws InterruptedException {
      final int numThreads = runnables.size();
      final List&amp;lt;Throwable&amp;gt; exceptions = Collections.synchronizedList(new ArrayList&amp;lt;Throwable&amp;gt;());
      final ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);
      try {
        final CountDownLatch allExecutorThreadsReady = new CountDownLatch(numThreads);
        final CountDownLatch afterInitBlocker = new CountDownLatch(1);
        final CountDownLatch allDone = new CountDownLatch(numThreads);
        for (final Runnable submittedTestRunnable : runnables) {
          threadPool.submit(new Runnable() {
            public void run() {
              allExecutorThreadsReady.countDown();
              try {
                afterInitBlocker.await();
                submittedTestRunnable.run();
              } catch (final Throwable e) {
                exceptions.add(e);
              } finally {
                allDone.countDown();
              }
            }
          });
        }
        // wait until all threads are ready
        assertTrue(&quot;Timeout initializing threads! Perform long lasting initializations before passing runnables to assertConcurrent&quot;, allExecutorThreadsReady.await(runnables.size() * 10, TimeUnit.MILLISECONDS));
        // start all test runners
        afterInitBlocker.countDown();
        assertTrue(message +&quot; timeout! More than&quot; + maxTimeoutSeconds + &quot;seconds&quot;, allDone.await(maxTimeoutSeconds, TimeUnit.SECONDS));
      } finally {
        threadPool.shutdownNow();
      }
      assertTrue(message + &quot;failed with exception(s)&quot; + exceptions, exceptions.isEmpty());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大致讲解下原理，首先CountDownLatch是java concurrent包里面的一个同步工具，用一个整数初始化，初始化之后调用await()是会持续block那里的，通过另外的线程不断的调用countDown，调用输入整数个countDown之后，之前block在await的线程会继续运行。&lt;/p&gt;

&lt;p&gt;上面的代码建立了一个线程池，把输入的Runnable封装成Runnalbe提交到线程池里，同时保证所有的线程都不在运行，记录有多少Runnable已经被提交了，有多少Runnable已经完成了。&lt;/p&gt;

&lt;p&gt;然后assert所有的线程在规定时间内都提交完成了。开始启动这些线程，再最后确保这些线程在规定时间内完成。当然，运行过程中所产生的exception都被记录在一个list中，最后assert有没有产生excpetion。&lt;/p&gt;

&lt;p&gt;基本上完成了测试的需求，美中不足的是如果有timeout或者exeption，单从测试的结果很难定位timeout或者exception的runnalbe。有改进的空间。&lt;/p&gt;

&lt;h4&gt;continuous test&lt;/h4&gt;

&lt;p&gt;The tests are run automatically after every change, usually in an intelligent order so that newest tests or most recently failed tests are run first。&lt;/p&gt;

&lt;p&gt;看起来很不错。有个叫infinitest（无尽的测试.....好冷）。可以放到intellij idea上面运行。&lt;/p&gt;

&lt;p&gt;至于infinitest的使用可以放到后面一个博客上面写&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>记一件蛋疼的事儿</title>
   <link href="http://tom.preston-werner.com/paper_room/2014/10/31/dt_thing.html"/>
   <updated>2014-10-31T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/paper_room/2014/10/31/dt_thing</id>
   <content type="html">&lt;p&gt;某个午后，mac突然陷入龟速状态，猜测是fusion drive的问题，无奈100多天没有time machine备份，没有底气格盘恢复，然后就扯出了一系列非常蛋疼的事儿。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;  花了很长时间搞了搞最近的备份。&lt;br/&gt;
  目前的状况是，备份是ok了，但是我想升级操作系统的时候遇到了问题，于是想先把重要的东西迁移到新的mac上面，然后自己再慢慢搞老的电脑，大不了割了装个新系统，然后再从time machine恢复。傻了吧唧的买了一根thunderbolt cable，今天终于到了，两个电脑连到一起的时候我傻眼了，尼玛坑爹呢，根本不能迁移好么，用网络迁移慢的要死，不用网络迁移压根找不到自己的目录。&lt;br/&gt;
  而且新的电脑在我接二连三的蹂躏之下系统里多了一些乱七八糟的东西，怒删之！ 我要重新做系统！！&lt;/p&gt;

&lt;p&gt;  迁移这条支线是不可能了，等我终于冷静下来之后，我开始一边备份自己的照片，一边考虑数据存储的问题，到底怎样的数据存储才是让自己放心的？&lt;/p&gt;

&lt;p&gt;  ###iphoto
  一个iphoto图库放在time machine里？ 不够放心，万一哪天升级了操作系统发现iphoto图库读不出来怎么办，所以要把所有照片导出单独存一份才安心。&lt;br/&gt;
  我担心的数据还有哪些？
  ###music &lt;br/&gt;
  音乐不多，而且大部分在云端。所以这个ok的。&lt;/p&gt;

&lt;p&gt;  ###code
  代码，折腾过的不少，但是真正有用的不多，不过这部分可以先不管三七二十一的放到github上面，顺便让那些半途而废的东西暴露在阳光下，鞭策一下自己。&lt;/p&gt;

&lt;p&gt;  ###account
  软件和账号，刚刚check了一下1password，发现经过之前的折腾，数据文件没了，不过也没关系。。。。反正也没放多少东西在里面，下面可以把这个作为主力，然后经常备份，至于是备份到dropbox里还是其他地方，到时候再说吧。&lt;/p&gt;

&lt;p&gt;  ###dmgs.....
  软件的话，说起来有些不光彩，有些很好用的软件没有购买正版，破解版的资源又不是那么好找，所以这部分丢了应该比较蛋疼。第一怪自己思想觉悟不够高，无耻的用盗版；第二怪自己没留后路，至少也备份一下当时那些软件的破解方法......第三，经过这次我尽量买正版。&lt;/p&gt;

&lt;p&gt;  ###文字性的东西
  如果还让我想比较心疼的东西，大约就是一些自己写的东西吧，平时虽然用的软件比较杂，mou, omni outliner, evernote，但是整理起来还是比较方便的，迁移的时候想到了evernote的好，但是evernote的编辑体验确实不怎么样。这块就整理一下能写成博客的就放在博客上，不能弄成博客的就打包下放在evernote里面。弄个applescript脚本周期性的整理应该还是很容易的。&lt;/p&gt;

&lt;h2&gt;  之后呢？&lt;/h2&gt;

&lt;p&gt;  毕竟生活还是要继续，老的mac看起来状态正常了点，新的mac尸骨未寒，处于没有操作系统的状态。冷静了一番之后决定还是别那么冲动了，还是先把自己的习惯整理好再去整理这两台电脑吧。新mac今晚装了系统，明天试试能不能从time machine中恢复出iphoto图库来，如果能那就升级到yosemite，看看能不能恢复出iphoto。老mac就一点点慢慢整理吧，等我觉得各项数据足够安全可恢复了，就割了重装，但是决定再也用坑爹的fusion drive了（这次不能直接升级yosemite就是因为它）。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>How to disable output to console</title>
   <link href="http://tom.preston-werner.com/language_related/2013/09/19/log4j_problems.html"/>
   <updated>2013-09-19T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/language_related/2013/09/19/log4j_problems</id>
   <content type="html">&lt;p&gt;log4j用的不熟悉，但是为了项目的log能thread-safe就改用了这个。。。&lt;br/&gt;
结果在邮件里被抱怨原文打到文件里的log现在在屏幕log里也有一份&lt;br/&gt;
遂在stackoverflow上找到帖子一张&lt;br/&gt;
&lt;a href=&quot;http://stackoverflow.com/questions/7513463/how-can-i-disable-output-to-log4j-rootlogger&quot;&gt;how can I disable output to log4j.rootLogger?&lt;/a&gt;&lt;br/&gt;
后来证实是additivity项的设置问题&lt;br/&gt;
在log4j的文档里面有这么一段话:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The output of a log statement of logger C will go to all the appenders in C and its ancestors. This is the meaning of the term &quot;appender additivity&quot;.

However, if an ancestor of logger C, say P, has the additivity flag set to false, then C's output will be directed to all the appenders in C and its ancestors upto and including P but not the appenders in any of the ancestors of P.

Loggers have their additivity flag set to true by default.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是一个log被传到rootlogger的appender里了，难怪info的时候到了stderr的输出里。目前自己的项目里直接把additivity设置为false就可以了，但是best answer给出的建议是把stdout, stderr从root logger里面去掉。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linux terminal shortcut</title>
   <link href="http://tom.preston-werner.com/tools/2013/09/05/linux_terminam_shortcut.html"/>
   <updated>2013-09-05T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/tools/2013/09/05/linux_terminam_shortcut</id>
   <content type="html">&lt;h1&gt;之前不太清楚的一些快捷键&lt;/h1&gt;

&lt;h2&gt;删除&lt;/h2&gt;

&lt;p&gt;ctrl+d  向右删除一个字符&lt;br/&gt;
ctrl+k  删除当前字符到行尾&lt;br/&gt;
ctrl+w  删除从光标到当前单词的开头&lt;/p&gt;

&lt;h2&gt;其他操作&lt;/h2&gt;

&lt;p&gt;ctrl+y  插入最近删除的单词&lt;br/&gt;
ctrl+d  当前操作赚到后台&lt;br/&gt;
ctrl+l  无敌清屏棒子&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>more vim</title>
   <link href="http://tom.preston-werner.com/tools/2013/08/18/more_vim.html"/>
   <updated>2013-08-18T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/tools/2013/08/18/more_vim</id>
   <content type="html">&lt;h2&gt;移动的命令&lt;/h2&gt;

&lt;p&gt;L 移动到屏幕的末端&lt;br/&gt;
20| 移动到第20列(囧，之前都是20-&gt;的)&lt;/p&gt;

&lt;h2&gt;replace&lt;/h2&gt;

&lt;p&gt;之前用0,$g/old/s//new/g用惯了，其实全局替换的话还是用&lt;br/&gt;
%s/old/new/g比较好,手指可以偷偷懒&lt;br/&gt;
%s/old/new/gi的话是case unsensitive, gc的话就是需要confirmation&lt;br/&gt;
另外s/old/new/替换第一个遇到的old, 而后面加个g的话替换该行所有遇到的old&lt;br/&gt;
g/string/d 的话则是删除含有string的行&lt;br/&gt;
v/string/d 是删除不含string的行&lt;br/&gt;
另外ctrl-a 和 ctrl-x分别是increment num 和decrement num简直是装逼必备的命令&lt;/p&gt;

&lt;h2&gt;case operation&lt;/h2&gt;

&lt;p&gt;Vu-&gt;lowercase line, V是选中当前行&lt;br/&gt;
VU-&gt;uppercase line&lt;br/&gt;
g&lt;del&gt;~-&gt;invert case
veU-&gt;uppercase a word, 这个指令是这么一回事，v是选择模式，e会选中当前的词，u是lowercase，U是uppercase&lt;br/&gt;
ve&lt;/del&gt;-&gt;把一个词的case翻转，如果单用~的话,是把光标下的char变成invert case&lt;br/&gt;
剩下的一些暴长无比的指令根本就没必要记了。只需记住用e选择一个word，U是将当前选中的区域uppercase，u是lowercase，而~是invert&lt;br/&gt;
不过我比较好奇的是为嘛图片里提到的set first letter of each word to uppercase 在我的vim里没有用&lt;/p&gt;

&lt;h2&gt;read/write files&lt;/h2&gt;

&lt;dl&gt;
&lt;dt&gt;一些比较上档次的文件读写命令：  &lt;/dt&gt;
&lt;dd&gt;1,n w outfile 1到n行的line写到outfile里&lt;br/&gt;
:1,n &gt;&gt; outfile 的话可自行脑补&lt;br/&gt;
:r infile insert the content of in file, 有了这个就不用每次很傻x的vs然后copy了&lt;br/&gt;
:23r infile insert the content of infile under line 23&lt;/dd&gt;
&lt;/dl&gt;

&lt;h2&gt;file explorer&lt;/h2&gt;

&lt;p&gt;基本没用过这货。。。&lt;br/&gt;
:e . 打开集成的file explorer&lt;br/&gt;
:Sex  ^ ^, split window and open explorer &lt;br/&gt;
:Sex!  ^ ^, vertically split window and open explorer &lt;br/&gt;
:ls list buffers&lt;br/&gt;
:args list files
:grep expression return a list of reg matching files
:gf open file name under cursor&lt;br/&gt;
目测最有用的可能是Sex和gf&lt;/p&gt;

&lt;h2&gt;interact with linux&lt;/h2&gt;

&lt;p&gt;:sh temporary returns to linux&lt;/p&gt;

&lt;h2&gt;tabs/windows&lt;/h2&gt;

&lt;p&gt;完全没用过这堆东西&lt;br/&gt;
:tabnew create a new tab&lt;br/&gt;
gt next tab&lt;br/&gt;
:tabfirst tablast&lt;br/&gt;
:tabdo command execute a command in all tabs&lt;br/&gt;
:tab ball puts all open files in tabs&lt;br/&gt;
:new abc.txt edit abc.txt in new tab&lt;/p&gt;

&lt;h2&gt;auto-completion&lt;/h2&gt;

&lt;p&gt;ctrl+n ctrl+p complete word, n是next的意思， p是prev的意思&lt;br/&gt;
ctrl+x ctrl+l complete line&lt;br/&gt;
:set dictionary=dict define dict as a dicitonalry  这个好像有点意思，这样话是不是可以把自己写的工作做个dictionary&lt;br/&gt;
ctrl+x ctrl+k complete with dicitonary&lt;/p&gt;

&lt;h2&gt;abbreviation&lt;/h2&gt;

&lt;p&gt;好像是个比较好玩儿的属性&lt;br/&gt;
:ab word word will be expanded to this&lt;br/&gt;
:una word&lt;br/&gt;
:abc clear all abbreviations&lt;/p&gt;

&lt;h2&gt;indent&lt;/h2&gt;

&lt;p&gt;=% indent code between parenthesis&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>chrome插件开发-browser aciton</title>
   <link href="http://tom.preston-werner.com/web/2013/08/15/chrome_browser_actions.html"/>
   <updated>2013-08-15T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/web/2013/08/15/chrome_browser_actions</id>
   <content type="html">&lt;p&gt;之前帮一个朋友做了一个自动调表的插件,自我感觉做的其烂无比。。。&lt;br/&gt;
但好歹也算是对javascript和chrome的开发有点小入门了,所以决定最近还是抽点时间看看文档和别人的源码，这样以后好歹能做点很酷的前端小插件了。&lt;/p&gt;

&lt;h1&gt;browserAction&lt;/h1&gt;

&lt;p&gt;browser action 可以包含四个元素，icon, tootip, badge, popup&lt;/p&gt;

&lt;h2&gt;icon&lt;/h2&gt;

&lt;p&gt;browser action最大可以有19dips。而设置icon有两种&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>与P4G一起的六个月</title>
   <link href="http://tom.preston-werner.com/game/2013/08/10/finish_p4g.html"/>
   <updated>2013-08-10T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/game/2013/08/10/finish_p4g</id>
   <content type="html">&lt;p&gt;今天是把P4G通关的日子&lt;br/&gt;
特地翻了一下日历,六个月之前的一个晚上，把P4G带回了家，当时手头的游戏要么已通，要么无聊，于是冲着psv平台排名第一的名头入手了P4G。一方面是不想停止游戏的进程，另一方面是打法一下年前一个周夜晚的时间。&lt;br/&gt;
刚开始是狂热了一阵，以至于在我开始年假之前就有十个小时的游戏时间了。但是现在回想一下原因只不过是刚开始的兴趣了，并不是传说中的“引人入胜的剧情”。&lt;br/&gt;
长剧情的RPG不玩儿到接近尾声大约是感觉不到剧情的引人入胜，而所谓引人入胜的剧情其实指的就是随着时间的推移，游戏留给你的回忆吧。所以P4G给我的感觉和仙剑系列给我的感觉是一样的。这些游戏留给大家的不是千篇一律在寝室一角开着台灯端枪厮杀或者团战之类的千篇一律的回忆（当然我也没说这样的回忆哪里不深刻）， 而是初二夏天你汗流浃背的游走在林家后院的隐蛇窟，初三冬夜你一边擦泪一边看景天和雪见最初的约定，高考前夕你和天河菱纱梦璃共赴琼华，这些点点滴滴在记忆中被慢慢拉长，直到遍布了你所有的回忆。&lt;br/&gt;
而P4G留给我的就是一个可以拉长的记忆区间，72个小时（中间走过n小时的弯路），半年的回忆，可能分散在每天每周并不长，但这就是以后的我们能记住的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>不在状态</title>
   <link href="http://tom.preston-werner.com/daily_record/2013/07/09/tired.html"/>
   <updated>2013-07-09T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/daily_record/2013/07/09/tired</id>
   <content type="html">&lt;p&gt;最近莫名其妙的累，感觉身体完全不在状态。&lt;br/&gt;
大约是自行车丢了然后我就失去了唯一的锻炼途径（如果这能称之为锻炼的话）了的缘故。晚上跟老妈打电话我妈还在电话那头边吃饭边咕噜咕噜的说“你晚上下班回来了就别对着电脑了，出去跑跑锻炼锻炼，我告诉你啊，年轻的时候一定要注意身体，咕噜咕噜。。。”。&lt;br/&gt;
最近深感对于我这样的普通人听长辈话的重要性，这里立文章为誓，以后每晚跑步半小时，来拯救我不在状态的身体。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>java enum singleton and related safe problems</title>
   <link href="http://tom.preston-werner.com/language_related/2013/07/06/java_enum_singleton_and_reflection_attack.html"/>
   <updated>2013-07-06T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/language_related/2013/07/06/java_enum_singleton_and_reflection_attack</id>
   <content type="html">&lt;p&gt;晚上在stackoverflow上闲晃，查找google的java库的相关信息的时候，看到了用enum singleton单例的写法,就顺便花时间了解了一下几个单例:&lt;br/&gt;
单例要保证的是一个进程只有一个实例，一般性的写法是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Singleton {
    private static Singleton singleton = new Singleton();

    private Singleton() {}

    public Singleton getSingleton()
    {
        return singleton;
    }
}

还有lazy implementation, 就是我常用的bob方法，其他古老的方法就不说了
class Singleton {
    private static class SingleHolder {
        public static Singleton singleton = new Singleton();
    }

    private Singleton() {}; 

    public Singleton getSingleton()
    {
        return SingleHolder.singleton;
    }
}
只要不访问SingleHolder就不会触发singleton的构造，所以不访问getSinleton()函数是不会生成单例的.

而enum实现单例更简单一些
enum Singleton {
    INSTANCE;

    Singleton() {
    //your code
    };

    private xxx;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最古老的方法不可考了也不想考了，中间了方法是我一直在稀里糊涂用着但是不知道为什么的方法，现在想想唯一的好处就是lazy implementation和不用加synchornized关键字的线程安全。至于知道enum 的这种实现方法，是看到stackoverflow上的大牛鄙视一个小菜鸟的时候顺便学到的（大牛对小菜一通鄙视，从封装到singleton，最后索性来了一句jactually everything you said is wrong, blah, blah, blah, read effective java, blah, blah，我自己也顺便中了一枪）。&lt;/p&gt;

&lt;p&gt;采用前两种方法会产生两个安全性问题：1、reflection attack 和 2、deserialization attack。第一种说的是可以通过反射调用似有函数，从而产生新的instance，后者说的是通过序列化和反序列化能产生新的实例，这样赤裸裸的对单例的侵犯是难以忍受的，所以衍生出了一些办法来对付这俩问题，对于前者，&lt;a href=&quot;http://initbinder.com/articles/hack_any_java_class_using_reflection_attack.html&quot;&gt;这篇讲reflection attack的blog&lt;/a&gt;里有详细的介绍，对于后者，readReslove里抛异常之类的奇思妙想也是比比皆是。&lt;br/&gt;
但是如果用enum来实现单例的话直接就能解决这俩问题，不信你看java这个语言的设定----&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.9&quot;&gt;enum specification&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;**The final clone method in Enum ensures that enum constants can never be cloned, and the special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization. Reflective instantiation of enum types is prohibited. Together, these four things ensure that no instances of an enum type exist beyond those defined by the enum constants.**
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后附上wiki里面对java singleton的&lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;详尽介绍&lt;/a&gt;&lt;br/&gt;
还有enum在java中的&lt;a href=&quot;http://www.cnblogs.com/frankliiu-java/archive/2010/12/07/1898721.html&quot;&gt;具体实现&lt;/a&gt;，一篇不错的中文文章.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>中国国民性演变历程读后感</title>
   <link href="http://tom.preston-werner.com/paper_room/2013/07/06/book-review.html"/>
   <updated>2013-07-06T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/paper_room/2013/07/06/book-review</id>
   <content type="html">&lt;h2&gt;前面的话&lt;/h2&gt;

&lt;p&gt;坐在这里写这个东西的时候有点小小的得瑟掺杂着淡淡地愧疚。。。&lt;br/&gt;
翻了翻之前的博客，发现这本书本该是半个月前就看完的---一个月前定的书单上还有一本书完全没动，另外一本技术书则处于半死不活的看两页歇两天的状态。。。&lt;br/&gt;
想想上月定计划时候的雄心壮志，真是应了《国民性》这本书最后章节对鲁迅等人的评价---“速成论”。&lt;br/&gt;
废话就不说了，讲讲这本书。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;印象&lt;/h2&gt;

&lt;p&gt;这本书买回来第一天我就翻了一两章，看完就感觉这是一本很主观的书，虽然很有做学问的样子。但是后来我就释然了，慢慢的开始把这个书当成了段子书看。仔细掰掰我匮乏的阅读史，真没看过太多的历史类的书籍，大家在看《明朝那些事儿》的时候我大抵在抱着《鬼吹灯》研究摸金倒斗的东西，所以没有和其他段子历史书和其他严肃历史书比较的余地。不过这样也好，最起码不会枯燥了，也了解了以后吹牛逼能用得着的历史段子。&lt;br/&gt;
书分为三大部分，先是按照作者的思路撸一遍各朝各代的国民性状况，大抵是春秋的贵族，淳朴的汉，大明的流氓满街窜，跟大家耳濡目染的历史无甚区别，稍微侧重讲了一下时代的个人精神风貌和制度。第二部分就回到先秦去了，探源国民性，而且拉出了几乎同时代的希腊，一边掰咱们为啥会专制，一边掰希腊为什么会民主。&lt;/p&gt;

&lt;h3&gt;先秦的发展时间线基本是&lt;/h3&gt;

&lt;p&gt;&lt;font color=&quot;green&quot;&gt;
黄河流域生态好 -&gt; &lt;br/&gt;
形成原始部落，大家不愿意乱跑-&gt;&lt;br/&gt;
人口增多，资源紧张-&gt;&lt;br/&gt;
开始部落联合，打仗，武力统一-&gt;&lt;br/&gt;
禅让，但是禅让仅限于让自己爽的人，基本上是把闺女嫁给你，让儿子监督你，等自己差不多老死你就是自家人的火候才会禅让给你-&gt;&lt;br/&gt;
有人不爽禅让，开始夺权-&gt;&lt;br/&gt;
建立夏朝-&gt;&lt;br/&gt;
太暴虐被推翻，商朝 -&gt;&lt;br/&gt;
太暴虐被推翻，周朝 -&gt;&lt;br/&gt;
家天下，后来发现自己爷爷的爷爷的兄弟的孙子的孙子的儿子跟自己的关系也就这样，灭亡-&gt;&lt;br/&gt;
春秋-&gt;&lt;br/&gt;
礼乐崩坏，所有人都不爽的时候，秦始皇顺应历史变化统一了全国.&lt;br/&gt;
&lt;/font&gt;
基本上从部落时代人就开始被氏族，父权，给统治了，所以父权发展到了令人发指的程度也不奇怪，衍生出君权也是顺理成章的事儿，在不关心个人的社会里，集权统一才是最稳定的状态。&lt;/p&gt;

&lt;h3&gt;希腊的历史发展线基本是&lt;/h3&gt;

&lt;p&gt;&lt;font color=&quot;green&quot;&gt;
生态恶劣啊尼玛，不能种地-&gt;&lt;br/&gt;
航海-&gt;&lt;br/&gt;
航海-&gt;&lt;br/&gt;
老头子不能航海，凭什么无条件尊敬你-&gt;&lt;br/&gt;
有钱人才是牛逼的人，父权神马的滚粗吧-&gt;&lt;br/&gt;
钱-&gt;&lt;br/&gt;
钱-&gt;&lt;br/&gt;
所有的事儿都变成了有条件的，包括效忠君主-&gt;&lt;br/&gt;
奴隶要暴动了，聪明人站出来解放了奴隶-&gt;&lt;br/&gt;
有了人权-&gt;&lt;br/&gt;
反复折腾&lt;br/&gt;
&lt;/font&gt;
虽然有点扯淡，但是看上去确实是由于生态恶劣，于是身强体壮的人能够出海闯天下，而老头子的智慧和经验只能在安稳的平原才能发挥作用，于是父权逐步被利益的追逐取代了。其实我一直觉得解放人的本性才是正道，解放了才有可能去控制，本性和大小便本质上都是一个东西，宜疏不宜堵，可惜的是通晓这个道理的大禹却不通晓人性（这样不是在骂他吧？）。&lt;br/&gt;
那终极问题来了？ 到底是什么导致了刚开始的不同呢，大约：鬼知道。。。问上帝去吧。&lt;br/&gt;
当时看这个章节的时候由于和希腊做了比较，想到了很多不同的东西，看来果真是有比较才会有思辨。&lt;/p&gt;

&lt;h2&gt;认识胡适，反思自己&lt;/h2&gt;

&lt;p&gt;让我看的最津津有味的还是最后的章节，讲近现代中国国民性的改造。其实主要有两种思潮了，梁启超大约是早期影响最深的人物了，提出了改造国民性首先要从改造人开始，想法不错，影响了鲁迅，蒋介石，陈独秀，毛泽东等一把帮子人，其对国民性的总结影响了之后整整无数代人，但是改造方式。。。不是还没跳出“修身治国然后才平天下”的笼子吗。&lt;br/&gt;
也是这个部分，让我对胡适的政治思想有了初步的认识，跟鲁迅不同的是，胡适写文章向来是实名制，对自己的任何言论都要负法律责任，在鲁迅狂换笔名写小说的时候，胡适也在做着写文章的事儿，只不过胡适更多的是针对现实的问题发表评论，随后提出解决办法，当时的国民党从中受益匪浅。
胡适对国民性改革的想法是稳重的解决问题，既然开始向民主化推进了，那就是进步，我们慢慢的解决问题就行了，西方推了那么多年才会形成微妙的民主平衡，我们慌什么呢慌什么呢？但是这与当时主流知识分子的观点背道而驰，求速的思潮大约也是从那个时候开始的吧，从康有为开始就有“三年而红规成”了，想想跟我党的“三年赶英，五年超美”何其相似，随后的各个事件都伴随着知识界的一次次动荡，今年立宪不行，明天要废除汉语，过两年不信任青年了，最后开始想走沙俄路线了，这些都是大谈主义不解决问题的人。按照胡适先生的设计能否成功改造国民性已经无从验证了，但是在当时充斥着“速成伦”和“真理唯一论”的当时能够稳重的解决问题实属不易，按照胡适先生自己的话说，只求减少内心的复旧感，什么是真性情，这就是真性情。&lt;br/&gt;
可惜的时候新中国成立后这种思潮依然未变，不幸的是之前都是动笔杆子的人，现在是个动枪杆子的人，于是。。。就有个大家熟知的各种“三分过”了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;其实这本书让我看最后几章就行了，不仅开始了解一个人了，而且从上面看到自己性格中的一些硬伤。急躁，求速成，做事儿的时候希望能迅速找到一个“简单而又伟大的准则”，一元思维。&lt;br/&gt;
但是&lt;br/&gt;
&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;世界那么复杂，哪可能那么简单&lt;/strong&gt;&lt;/font&gt;？&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>不吹会死</title>
   <link href="http://tom.preston-werner.com/paper_room/2013/07/05/two_blogs.html"/>
   <updated>2013-07-05T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/paper_room/2013/07/05/two_blogs</id>
   <content type="html">&lt;p&gt;好吧，本来这将会是一篇痛心疾首的自省文，可以这是早上的构想，一个小时前发生的一切已经不可阻挡的把该文的主题掰弯成了吐槽文，历史的车辙啊，碾压吧。。。。。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;你旁边有喜欢吹嘘别人的哥们吗？没到天花乱坠的程度，别人放个屁都能炸红了半边天那种程度，吹别人的时候顺便渗透一下自己早就看透了一切的普世价值观, 多于三人存在的时候更精彩，轮流褒奖大家，&quot;哎呦x哥牛逼，x哥做的都是功夫，咱们搞的都是表面的东西&quot;, 然后在褒奖别人的时候顺便黑你一下，每当这个时候我都想大呼“黑的漂亮”，因为每次被黑的都是我。&lt;br/&gt;
由于性格的原因，我很荣幸每次都成为被黑的那个，数次完美的躺枪并没有让我感觉哪里不爽，因为出来混迟早要还嘛，谁让我平时不积口德了呢。&lt;br/&gt;
但是今天发生的事却深深的震撼了我（好吧。。。我装逼，其实是深深的激怒了我），我实在不明白为什么会有人把吹嘘别人当做自己的兴趣或者习惯，这得是多么的无聊啊，你说你人生中没有乐趣也就算了，干嘛动不动就搞造牛运动呢。这是为什么呢为什么呢为什么呢？&lt;br/&gt;
坐公交的时候我就想到了前两天看到王垠之前写的一篇文章，说在google实习的时候整个公司都充斥着一种非理性的文化思潮中，整天讨论牛人，对创始人的膜拜达到了耶稣的程度，对各路只闻其名，不见其人的牛人的吹捧达到了令人发指的成都。其实我心目中一直很仰慕google这家公司的，所以看到王垠的那篇文心中有一点淡淡地失落（你失落个屁啊。。。又不是你家公司），更多的是对文中提到的那种现象的关注。&lt;br/&gt;
现在可好了，身边有一个活生生的例子能让我感同身受了。&lt;br/&gt;
我觉得这个事儿背后的问题就是自我价值观的不完善, 说白了就是没有活出自己的style来，一个独立的人是不会下意识的开始吹嘘别人的。可是为什么呢？我看他整天看书也挺多的啊，难道都到狗身上去了吗？还是由于小时候论语没学好不知道学而不思则罔的道理呢？省下去吹嘘别人的功夫多去想想工作的事儿和自我修行的事儿多好呢。&lt;br/&gt;
吹嘘跟赞美是两回事儿，最大的区别是吹嘘会让人感觉讨厌，无论是吹嘘自己还是吹嘘别人, 但是现在脑残才吹嘘自己，找喷啊?这种满载着负能量的行为说白了是为了否定，吹嘘别人，为的是告诉你人多牛逼，丫赶不上，我吹嘘别人然后再黑自己一下，是为了告诉你人多牛逼，丫最多和我一样，我特么都赶不上了，你能吗能吗能吗？&lt;br/&gt;
尼玛啊，你真以为所有人的世界观都一样狭隘吗？ 废话，你当然会这么以为，多说无益，继续吹去吧。。。。哥不陪你玩儿了&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>osx下编译so的困难记录</title>
   <link href="http://tom.preston-werner.com/mac/2013/07/04/g%2B%2B-things2.html"/>
   <updated>2013-07-04T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/mac/2013/07/04/g++-things2</id>
   <content type="html">&lt;p&gt;昨天一度以为那个模块编好了就一劳永逸了，结果今天早上到了之后又悲剧的发现还有另外一个东西要编译，sigh，为了工作正常展开，为了不倒退到ubuntu时代，只能上了。&lt;/p&gt;

&lt;p&gt;首先遇到的问题是一个文件中用了SOCK_NONBLOCKING，翻了一下socket的manual, 发现果然没有（当时狗眼瞎了，没有看到赫然印着的&lt;font color=&quot;red&quot;&gt;BSD system calls manual&lt;/font&gt;）, 还在傻乎乎的想，是不是我g++版本的问题，导致没有这个东东呢。。。捂脸。。。&lt;br/&gt;
正如网页&lt;a href=&quot;http://www.gnu.org/software/libc/&quot;&gt;gnu c library&lt;/a&gt;上说的那样，unix-like 系列的操作系统都需要一个定义了系统调用和其他如open，malloc之类基础设施的c语言库，在mac里，被放在了/usr/lib/system中。回忆一下系统库和标准c库之间的不同，省的再次头昏脑涨。&lt;br/&gt;
至于为什么没有SOCK_NONBLOCK，跟内核有关，我大mac党躺枪....最后删了一些代码了事(我这边用不到那些)&lt;/p&gt;

&lt;p&gt;随后遇到的问题是&lt;code&gt;mach-o, but wrong architecture&lt;/code&gt;，是模块编译成功后dlopen该模块产生了问题，解决这个问题饶了一些弯子。&lt;br/&gt;
首先隆重介绍工具lipo, 这个是用来生成或者操作universal文件的，所谓universal文件就是multi-architecture文件,于是。。。我用它来查看架构。。。经过检查发现python的arch和要用库的都是x86_64，于是开始检查python, &lt;code&gt;defaults read com.apple.versioner.python&lt;/code&gt; 能够检查当前版本python的默认架构, 发现是坑爹的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;Prefer-32-Bit&quot; = 1;
    &quot;Prefer-64-Bit&quot; = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;难怪会有&lt;code&gt;wrong architecture&lt;/code&gt;的问题，改之，然后就能正确的运行了。顺手查了一下dlopen(), 里面提到&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;dlopen() can load dynamic libraries and bundles.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这就跟上一篇文章里面的说法不太一致了，这个事儿还是留时间做做实验吧.&lt;/p&gt;

&lt;p&gt;还有一个遗留问题，晚上查吧&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>osx下编译dylib的知识记录</title>
   <link href="http://tom.preston-werner.com/mac/2013/07/03/g%2B%2B-things.html"/>
   <updated>2013-07-03T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/mac/2013/07/03/g++-things</id>
   <content type="html">&lt;p&gt;上午开个大半个上午的会&lt;br/&gt;
下午本想针对要做的事儿写出个初步的模型来，结果光是环境就折腾了大半天，万恶的移植
遇到的问题主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;g++中的-std指令中用到的几个参数有什么不同？发现std::stoi这个函数还有std::to_string()这个函数是不存在的，跟那些参数有关吗？还是跟平台有关？&lt;br/&gt;
是不同的c++标准，i686-apple-darwin11-llvm-g++-4.2 (GCC) 4.2.1的stdlib里没提供这两个函数，暂时不想研究&lt;/li&gt;
&lt;li&gt;&lt;p&gt;osx中的g++的库文件跟linux有什么不同，发现找了半天没找到的一个so文件被我改成dylib文件就成了，还有其他不同的地方吗？&lt;br/&gt;
找到了&lt;a href=&quot;http://docstore.mik.ua/orelly/unix3/mac/ch05_03.htm&quot;&gt;一篇不错的文&lt;/a&gt;，虽然有点一知半解，大致了解了linux体系中的二进制文件采用的是ELF格式，而mac中采用的是Match-O格式。在elf格式中，shared libraries 和 loadable module是一样的。但是在Match-O体系中，这两个东西是有着严格区别的。&lt;br/&gt;
前者用otool显示出来的类型是DYLIB，后缀是dylib，只能静态链接，如果用dyld API的话可以动态加载。  * 后者叫做bundles，虽然mac推荐用.bundle的后缀，无奈linux党太强大了，还是缀以了so。在mac中bundle只能动态加载和反加载（也要用dyld），不能链接。
然后就是一大堆例子了。。。感觉mac下的东西很难用的样子。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还有就是boost的具体功能是什么，与stl的异同在哪里？另外就是几个不明所以的库，libev和libevent？估计查查manual就可以了
boost 就是一组功能性的程序库，广泛采用template实现，也许这是跟stl唯一的相同点吧。。。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;libev是Marc Lehmann用C写的高性能事件循环库。通过libev，可以灵活地把各种事件组织管理起来，如：时钟、io、信号等。libev在业界内也是广受好评，不少项目都采用它来做底层的事件循环。
libevent是一个异步事件处理软件函式库，以BSD许可证发布。&lt;br/&gt;
libevent提供了一组应用程序编程接口（API），让程式设计师可以设定某些事件发生时所执行的函式，也就是说，libevent可以用来取代网络服务器所使用的事件循环检查框架。&lt;br/&gt;
由于可以省去对网络的处理，且拥有不错的效能，有些软件使用libevent作为网络底层的函式库，如：memcached、Tor。&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;p&gt; 好吧，模型的事儿就明早折腾吧，最基础的设施刚刚搭建起来，还不确定能不能用......&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>日参省乎己-07-22</title>
   <link href="http://tom.preston-werner.com/daily_record/2013/07/02/self-thinking.html"/>
   <updated>2013-07-02T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/daily_record/2013/07/02/self-thinking</id>
   <content type="html">&lt;p&gt;刚刚洗澡的时候突然想到了近两天闲暇时光的所作所为&lt;br/&gt;
往往是阳光烂漫的上午或者是昏昏欲睡的午后，红茶一杯，转椅一柄，关键词二三，然后就是漫无目的的扫荡相关的技术文章。&lt;br/&gt;
这样其实是不对滴， 原因有下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;效率低下。漫无目标，扫荡了一遍估计大部分也在扫荡结束的时候忘记了，虽然现在有写博客记录的习惯了，但是盯着一个妹子泡和满大街瞄然后号称我要泡妹子哪个效率高一目了然。&lt;/li&gt;
&lt;li&gt;容易分散精力，文章里面可以分散精力的东西太多了，这边还在研究java的classloader，那边很容易就被“jvm上的十大未来语言”吸引住了眼球。&lt;/li&gt;
&lt;li&gt;没成就感。。。漫无目的的扫荡鸟问题都解决不了。这个是最主要的问题。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以以后还是要多多的抱着解决某个实际问题的想法去学习，这样效率，精力和成就感上都有保证，而且会更有利于时间管理吧。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>java里的classloader</title>
   <link href="http://tom.preston-werner.com/language_related/2013/07/02/classloader.html"/>
   <updated>2013-07-02T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/language_related/2013/07/02/classloader</id>
   <content type="html">&lt;h1&gt;java的classloader&lt;/h1&gt;

&lt;h2&gt;基本概念&lt;/h2&gt;

&lt;p&gt;java的classloader的作用是动态的将class载入jvm&lt;br/&gt;
jvm运行的时候，用到了三个classloader:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bootstrap classloader  ---用来加载java最核心的class，需要加载的class在jre/lib中，bootstrap是在jvm中的，所以写java代码的时候我们是看不到的，通过-Xbootclasspath可以指定加载哪些core api&lt;/li&gt;
&lt;li&gt;extension classloader   ---加载标准拓展库的classloader, 需要加载的类在jre/lib/ext中&lt;/li&gt;
&lt;li&gt;sys classloader ---从环境变量配置的classpath中来查找路径，设置classpath即可&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  Class.getClassLoader()会得到当前类的classloader，如果该类是String之类的class， 那么加载它的classloader就是bootstrap classloader， 如果是classpath中的包，那么会得到system classloader, ext classloader 也一样&lt;br/&gt;
  ##parent delegation
  classloader 加载类的时候会采用双亲委托的模型。在当前classloader需要加载一个类的时候，先委托其parent去加载这个类，如果parent找不到这个类，自己才开始加载。这里的parent并不是superclass， 而是一个引用关系，也就是按照上面提到的那个顺序。&lt;br/&gt;
  这样做的好处就是提升安全性，比如你自己实现的String就不会被加载到jvm中，因为首先会加载的是core api中的class。&lt;br/&gt;
  ##class1 == class2 ?
  在比较两个class是否相等的时候，不仅比较两个class的名字是否相等，还要比较加载两个class的是否为同一classloader，只有两个条件同时满足的时候，才会认为两个class是等价的，否则就会出现转型错误&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;  当当当当，以上是大致的概念，不过都没有提到configuration里面用到的contextclassloader&lt;br/&gt;
  不过解释还是有点难懂，估计短时间内也用不着，先放着吧&lt;br/&gt;
  留下一个链接，日后慢慢研究 &lt;a href=&quot;http://www.javaworld.com/javaworld/javaqa/2003-06/01-qa-0606-load.html&quot;&gt;find a way out of the classloader maze&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>dataFu印象</title>
   <link href="http://tom.preston-werner.com/data_gunner/2013/07/01/datafu.html"/>
   <updated>2013-07-01T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/data_gunner/2013/07/01/datafu</id>
   <content type="html">&lt;p&gt;datafu是linkedin（虽然我现在还没用过。。。）内部用到的一个pig udf的集合，稳定，经过良好的测试。&lt;br/&gt;
主要用于大规模数据挖掘和数据统计。&lt;br/&gt;
好吧，以上是官方说法，我花了一点时间扫了一下里面的udf（&lt;a href=&quot;http://linkedin.github.io/datafu/docs/javadoc/&quot;&gt;javadoc在这里&lt;/a&gt;，里面的东西好少），用途最大的大约是datafu.pig.bags包和datafu.pig.bags.sets里面的函数了，前者是针对bag类型的一些常见操作，后者弥补了pig中没有set操作的缺陷，虽然只有intersetc和union两个函数&lt;/p&gt;

&lt;p&gt;剩下的包里面大约是我这辈子都不会用到的一些函数了，pagerank，haversinedist,不过应该能拿来做一些好玩儿的事情&lt;/p&gt;

&lt;p&gt;  顺便翻了一下里面的源码，util里面有些不错的东东&lt;br/&gt;
  目测比较实用的有SimpleEvalFunc,　实现pig udf的exec要从Tuple arg0里面提取参数并转型，这样就涉及到类型检查之类的操作（实际上从来没做过类型检查= =， 但是吃过这方面的亏），这个函数把这一些检查操作进行了封装，只需要实现call函数，就会自动完成一些列的操作。&lt;/p&gt;

&lt;p&gt;  另外工具包里的代码都有着良好的实现，构造函数和outputSchema函数一应俱全，exception更是给的恰到好处，更是包含了平时不可能用到的Accumulator的实现，对于刚开始学习pig的人写udf应该会带来很大帮助。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jpype的一些事儿</title>
   <link href="http://tom.preston-werner.com/language_related/2013/06/22/introduction-to-jpype.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/language_related/2013/06/22/introduction-to-jpype</id>
   <content type="html">&lt;h1&gt;Jpype的一些事儿&lt;/h1&gt;

&lt;p&gt;Jpype提供了python访问java代码的能力，但是实现上不同于Jython语言（没错，这货是门语言），Jpype只是一个库。&lt;br/&gt;
由于有一个移植小工具的需求，于是就用到了Jpype，琢磨了一番之后，深感方便。下面就简单的讲讲&lt;/p&gt;

&lt;h2&gt;how to use ?&lt;/h2&gt;

&lt;p&gt;首先当然是安装啦，从&lt;a href=&quot;http://jpype.sourceforge.net&quot;&gt;官网&lt;/a&gt;上下载， 解压，然后就。。。当当当当！可以用了！&lt;/p&gt;

&lt;h4&gt;start a jvm&lt;/h4&gt;

&lt;p&gt;Jpype的核心包是jpype， jpype是从jvm的native层进行调用的，首先要做的操作是打开jvm虚拟机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from jpype import *

jvmPath = getDefaultJVMPath()

startJVM(jvmPath)
shutdownJVM()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   这里的jvmPath是能够自己设置的, getDefaultJVMPath()给出的只是当前系统下默认的jvmpath, 以os x为例， 可以看到给出的默认getDefaultJVMPath()函数是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def getDefaultJVMPath() :
# on darwin, the JVM is always in the same location it seems ...
return '/System/Library/Frameworks/JavaVM.framework/JavaVM'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  没错，我要讲的就是那句贱贱的注释传达的意思，至于linux和window平台，稍微复杂一点，所以自行设置还是比较靠谱的&lt;br/&gt;
  只是开关虚拟机当然没什么意思了，而且我们用Jpype的目的并不是&quot;hello, world&quot;,所以我们直接跳过hello world的步骤，直接开始学着调用你自己的java代码&lt;/p&gt;

&lt;h4&gt;call your java code&lt;/h4&gt;

&lt;p&gt;   你有两种方式放置你要调用的java代码，直接编译，把所有的东西放在一个文件夹里，或者使用一个jar包，总之这个自己来控制吧。下面直接假设你所有的东西都在一个叫temp.jar的java的jar包里了&lt;br/&gt;
   Jpype比较弱的一点是要你自己指定classpath, 我们假设temp.jar就在当前的文件夹下，于是classpath肯定会是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   然后我们就可以打开虚拟机了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from Jpype import *

ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
startJVM(getDefaultJVMPath(), &quot;-Djava.classpath.path=&quot;+ext_classpath)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   下面做一个假设&lt;/p&gt;

&lt;p&gt;   这个temp.jar中有一个你想要的调用的class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package trial.jpype;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import trial.jpype.CoreDataType.NameComponents;


import trial.on.jpype.shuaizki;

import me.shuaizki.util.IO.MyIO;

public class namenormalizer {

public static void speak1()
{
    System.out.println(&quot;blah..blah..blah&quot;);
}

public static String getNormalizedName(String str)
{
    NameComponents nc = NameSplit.getSingleton().getNormalizedName(str);
    return ncToJson(nc);
}

public static String ncToJson(NameComponents nc)
{
    String ret = &quot;{&quot;;
    return ret;
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想调用的是namenormalizer中的getNormalizedName和speak1，首先要获取namenormalizer这个class，有两种途径获取这个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namenormalizer = JClass('trial.jpype.namenormalizer')
利用
ns = namenormalizer() 获取namenormlaizer 的一个对象
利用ns.getNormalizedName(“hello”)调用或者直接利用 namenormalizer.getNormalizedName()进行调用， 这样就完成了类的获取和函数的调用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种途径是利用Jpackage()这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namenormalizer = JPackage('trial').jpype.namenormalizer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   其实看看源码就会知道jpackage对类的访问依靠的也是jclass，只不过其提供了对包的访问。归根结底能找到类还是要依靠_jpype.findClass()这个函数，也就是C++代码里的东西，这个后面会有介绍。&lt;/p&gt;

&lt;h4&gt;运行代码的注意事项&lt;/h4&gt;

&lt;p&gt;   好了，我们最后的代码长成这个样子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from Jpype import *

ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
startJVM(getDefaultJVMPath(), &quot;-Djava.classpath.path=&quot;+ext_classpath)
namenormalizer = JClass('trial.jpype.namenormalizer')
namenormalizer.getNormalizedName(&quot;hello&quot;)

shuwdownJVM()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   尝试着运行一下吧~&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; namesplit = JClass('trial.jpype.namenormalizer')
 File &quot;/Library/Python/2.7/site-packages/jpype/_jclass.py&quot;, line 54, in JClass
raise _RUNTIMEEXCEPTION.PYEXC(&quot;Class %s not found&quot; % name)
 jpype._jexception.ExceptionPyRaisable: java.lang.Exception: Class
 trial.jpype.namenormalizer not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  纳尼！！！这是什么情况，找不到呢
  看一下我们的代码，发现没什么问题，包也在，那是为什么呢? 如果你用eclipse 的话，打开你的.classpath看看吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;classpath&amp;gt;
    &amp;lt;classpathentry kind=&quot;src&quot; path=&quot;src&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;src&quot; path=&quot;test&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.launching.macosx.MacOSXType/Java SE 6 (MacOS X Default)&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/protobuf-java-2.4.1.jar&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/gson-2.2.4.jar&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;output&quot; path=&quot;bin&quot;/&amp;gt;
&amp;lt;/classpath&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   如果你不用eclipse，肯定自己知道你用了一些外部包了。这些都要统统放在classpath里，不然Jpype自己是找不到的
    把这些lib里的东西都放在classpath里就行了，代码应该就能运行ok了&lt;/p&gt;

&lt;h4&gt;debug建议&lt;/h4&gt;

&lt;p&gt;如果还是跑不起来的话，那就重新编译一下JPype，让他打出debug信息，自己慢慢琢磨一下吧&lt;br/&gt;
打开src/native/common/include/jpype.h这个文件，第23行的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//#define JPYPE_TRACING_INTERNAL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  被注释掉了，将它恢复正常了吧，然后回到Jpype的目录下，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo python setup.py build -f
sudo python setup.py install -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  再运行你的代码的话，就会看到tracing信息了，剩下的就自己慢慢琢磨去吧&lt;/p&gt;

&lt;h2&gt;原理&lt;/h2&gt;

&lt;p&gt;jpype其实用的是jni实现&lt;br/&gt;
JNI就是Java Native Interface, 即可以实现Java调用本地库, 也可以实现C/C++调用Java代码, 从而实现了两种语言的互通, 可以让我们更加灵活的使用。&lt;br/&gt;
之前没听过的同学可以自行学习学习&lt;br/&gt;
利用c++完成对java调用的代码，做成python的库，这就是jpype的全部，实现全在代码里，大家自行参考喽&lt;br/&gt;
后面我会抽时间写写关于jni的博客，顺便解析一下jpype的实现&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>hadoop源码阅读-configuration</title>
   <link href="http://tom.preston-werner.com/data_gunner/2013/06/22/hadoop-configuration.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/data_gunner/2013/06/22/hadoop-configuration</id>
   <content type="html">&lt;h1&gt;configuration&lt;/h1&gt;

&lt;p&gt;实现了Interable&amp;lt;Map.Entry&amp;lt;String, String&gt;&gt;接口和Writable接口&lt;/p&gt;

&lt;h2&gt;私有变量&lt;/h2&gt;

&lt;p&gt;比较关键的私有变量有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;Object&amp;gt; resources; 
记录各个资源文件，configuration里总共有四种形式了  
    String（文件名）， URL, Path(hadoop 自己定义的), 还有inputstream
    在loadresource的时候，用instanceof进行判断然后加载

Set&amp;lt;String&amp;gt; finalParameters; 
    记录了const的哪些配置变量（比如hdfs-site.xml里面的dfs.replication, 被设置成了final）

boolean loadDefaults = true; 用于确定是否加载默认资源(默认加载哦)

private static final WeakHashMap&amp;lt;Configuration,Object&amp;gt; REGISTRY = 
new WeakHashMap&amp;lt;Configuration,Object&amp;gt;(); 各个Conf对象的一个注册表

private static final CopyOnWriteArrayList&amp;lt;String&amp;gt; defaultResources =
new CopyOnWriteArrayList&amp;lt;String&amp;gt;(); 默认资源的一个列表, CopyOnWriteArrayList是线程安全的哦

private boolean storeResource; 是否要存储下面的hashmap

privte HashMap&amp;lt;String, String&amp;gt; updatingResource; 存储某个配置项的来源资源文件

其次是configuration里面的两个个Properties类型的变量,
properties存储所有的配置项目, overlay存储所有被覆盖的配置
还有classloader变量，是当前线程的contextclassloader, 或者是当前类的classloader（如果前者为空的话）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;方法&lt;/h2&gt;

&lt;p&gt;首先用一个静态块加载了&quot;core-default.xml&quot;和&quot;core-site.xml&quot;两个资源文件&lt;/p&gt;

&lt;h3&gt;线程安全&lt;/h3&gt;

&lt;p&gt;由于configuration是线程安全的，因而注意代码里面的同步，有趣的是在configuration的一个构造函数Configuration(Configutaion other)中，看到了这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.resources = (ArrayList)other.resources.clone();
synchronized(other) {
 if (other.properties != null) {
   this.properties = (Properties)other.properties.clone();
 }

 if (other.overlay!=null) {
   this.overlay = (Properties)other.overlay.clone();
 }
}

this.finalParameters = new HashSet&amp;lt;String&amp;gt;(other.finalParameters);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让人困惑的是为什么针对resources和finalParameters的操作并没有被synchronized&lt;/p&gt;

&lt;h3&gt;资源加载相关函数&lt;/h3&gt;

&lt;p&gt;properties并非启动或者生成对象的时候加载的，而是在需要的时候才会加载，因而当有新的资源需要载入的时候，需要一个函数清理当前的properties 和 finalParameters , 这样在需要用到的时候才能重新加载.其实这个函数很简单，设置properties == null ，clear finalParameters就行了&lt;/p&gt;

&lt;h3&gt;get 和 set函数&lt;/h3&gt;

&lt;h4&gt;基本类型和enum&lt;/h4&gt;

&lt;p&gt;各种各样的get和set函数，五花八门，针对各个基本类型
都是针对properties进行操作的，由于Properties这个类本身是线程安全的，因而各种函数都是天然的线程安全函数---除了一个需要特别实现的函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private synchronized Properties getOverlay() {
if (overlay==null){
  overlay=new Properties();
}
return overlay;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }&lt;/p&gt;

&lt;h4&gt;IntegerRangs类和函数&lt;/h4&gt;

&lt;p&gt;将字符串转化为整数区间的类，目前还不清楚具体的作用是什么，只看到了一个isIncluded， 竟然是用遍历所有range来判断是否被包含在内的，感觉相当弱。。。。&lt;br/&gt;
随着这个类提供的是一个getRange函数,获取IntegerRanges结果。
值得注意的是这里的IntegerRangs使用的是静态内部类，有关静态内部类的好处看&lt;a href=&quot;http://book.51cto.com/art/201202/317517.htm&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;get class&lt;/h4&gt;

&lt;p&gt;剩下的get函数就只剩下getclass系列了&lt;br/&gt;
封装的很全面，不过实际上还是调用Class.forName(name, true, classloader)&lt;br/&gt;
有一个不错的实现之前完全没见过，就是载入实现了某个接口的类，函数如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public &amp;lt;U&amp;gt; Class&amp;lt;? extends U&amp;gt; getClass(String name, 
                                     Class&amp;lt;? extends U&amp;gt; defaultValue, 
                                     Class&amp;lt;U&amp;gt; xface) {
try {
  Class&amp;lt;?&amp;gt; theClass = getClass(name, defaultValue);
  if (theClass != null &amp;amp;&amp;amp; !xface.isAssignableFrom(theClass))
    throw new RuntimeException(theClass+&quot; not &quot;+xface.getName());
  else if (theClass != null)
    return theClass.asSubclass(xface);
  else
    return null;
} catch (Exception e) {
  throw new RuntimeException(e);
}
}
运用了isAssignableFrom函数的特性, 判断当前Class是否是theclass the superclass 或者是 superinterface(两个类相等也返回true哦)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;get resouce&lt;/h4&gt;

&lt;p&gt;核心函数是classloader.getResource&lt;/p&gt;

&lt;h4&gt;loadResource&lt;/h4&gt;

&lt;p&gt;对xml的解析用的是javax.xml.parsers&lt;br/&gt;
loadResource(Properties, Object, boolean)
是个递归函数，每次函数被调用，都会对 Element root进行赋值，然后判断root的tagname是否是configuration，如果不是的话会出直接退出，如果是，逐个对root的childnode进行解析&lt;br/&gt;
如果子节点的tag那么是configuration，调用loadresource返回上面那个步骤。否则判断子节点的tagnode是否为property（真麻烦啊。。。不过这样强有力的保障了正确性）， blah…blah…解析子节点并放在properties和finalParmeter里面&lt;/p&gt;

&lt;h5&gt;总体的感觉是封装的很标准，也有很多值得借鉴的实现。不过因为功力不够的缘故，留下了一些疑问：&lt;/h5&gt;

&lt;h5&gt;1、某些为了保证线程安全而加的synchronized段，比如上面提到的那段&lt;/h5&gt;

&lt;h5&gt;2、不同类型的classloader用起来有什么区别，比如configuration里涉及到的两种类型&lt;/h5&gt;

&lt;h5&gt;3、configuration中用到hashCode的两个函数getLocalPath和getFile&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public File getFile(String dirsProp, String path)
  throws IOException {
  String[] dirs = getStrings(dirsProp);
  int hashCode = path.hashCode();
  for (int i = 0; i &amp;lt; dirs.length; i++) {  // try each local dir
    int index = (hashCode+i &amp;amp; Integer.MAX_VALUE) % dirs.length;
    File file = new File(dirs[index], path);
    File dir = file.getParentFile();
    if (dir.exists() || dir.mkdirs()) {
      return file;
    }
  }
  throw new IOException(&quot;No valid local directories in property: &quot;+dirsProp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果之前看看注释的话，这段代码应该会很容易理解了，其实就是dirs里面包含很多项的话，从里面选出一个来，如果满足条件就使用，否则就选下一个。&lt;br/&gt;
hashcode的使用是为了保证随即性。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>博客动起来了</title>
   <link href="http://tom.preston-werner.com/daily_record/2013/06/13/first-artical.html"/>
   <updated>2013-06-13T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/daily_record/2013/06/13/first-artical</id>
   <content type="html">&lt;h2&gt;博客动起来了&lt;/h2&gt;

&lt;p&gt;话说终于让博客动起来了。。。时隔产生这个想法n个月之后&lt;br/&gt;
不过庆幸的是这个想法最终没被忘记&lt;br/&gt;
小小得瑟一下自己跟拖延症做斗争的顽强勇气&lt;br/&gt;
以后就在这个上面写东西了, mark一下&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>本月书单</title>
   <link href="http://tom.preston-werner.com/booklist/2013/06/05/booklist-of-June.html"/>
   <updated>2013-06-05T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/booklist/2013/06/05/booklist-of-June</id>
   <content type="html">&lt;h2&gt;本月书单&lt;/h2&gt;

&lt;p&gt;1、中国国民性演变历程&lt;/p&gt;

&lt;h2&gt;&lt;img src=&quot;http://img5.douban.com/lpic/s26381229.jpg&quot; alt=&quot;中国国民性演变历程&quot; /&gt;&lt;/h2&gt;

&lt;p&gt;2、hadoop技术内幕-深入解析hadoop common和hdfs架构设计与实现原理&lt;/p&gt;

&lt;h2&gt;&lt;img src=&quot;http://img3.douban.com/lpic/s26376893.jpg&quot; alt=&quot;&quot; /&gt;&lt;/h2&gt;

&lt;p&gt;3、高效能人士的七个习惯&lt;br/&gt;
&lt;img src=&quot;http://img3.douban.com/lpic/s1152683.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>