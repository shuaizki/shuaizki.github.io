<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tom Preston-Werner</title>
 <link href="http://tom.preston-werner.com/atom.xml" rel="self"/>
 <link href="http://tom.preston-werner.com/"/>
 <updated>2013-06-22T18:02:19+08:00</updated>
 <id>http://tom.preston-werner.com/</id>
 <author>
   <name>Tom Preston-Werner</name>
   <email>tom@mojombo.com</email>
 </author>

 
 <entry>
   <title>Jpype的一些事儿</title>
   <link href="http://tom.preston-werner.com/2013/06/22/introduction-to-jpype.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/06/22/introduction-to-jpype</id>
   <content type="html">&lt;h1&gt;Jpype的一些事儿&lt;/h1&gt;

&lt;p&gt;Jpype提供了python访问java代码的能力，但是实现上不同于Jython语言（没错，这货是门语言），Jpype只是一个库。&lt;br/&gt;
由于有一个移植小工具的需求，于是就用到了Jpype，琢磨了一番之后，深感方便。下面就简单的讲讲&lt;/p&gt;

&lt;h2&gt;how to use ?&lt;/h2&gt;

&lt;p&gt;首先当然是安装啦，从&lt;a href=&quot;http://jpype.sourceforge.net&quot;&gt;官网&lt;/a&gt;上下载， 解压，然后就。。。当当当当！可以用了！&lt;/p&gt;

&lt;h4&gt;start a jvm&lt;/h4&gt;

&lt;p&gt;Jpype的核心包是jpype， jpype是从jvm的native层进行调用的，首先要做的操作是打开jvm虚拟机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from jpype import *

jvmPath = getDefaultJVMPath()

startJVM(jvmPath)
shutdownJVM()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   这里的jvmPath是能够自己设置的, getDefaultJVMPath()给出的只是当前系统下默认的jvmpath, 以os x为例， 可以看到给出的默认getDefaultJVMPath()函数是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def getDefaultJVMPath() :
# on darwin, the JVM is always in the same location it seems ...
return '/System/Library/Frameworks/JavaVM.framework/JavaVM'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  没错，我要讲的就是那句贱贱的注释传达的意思，至于linux和window平台，稍微复杂一点，所以自行设置还是比较靠谱的&lt;br/&gt;
  只是开关虚拟机当然没什么意思了，而且我们用Jpype的目的并不是&quot;hello, world&quot;,所以我们直接跳过hello world的步骤，直接开始学着调用你自己的java代码&lt;/p&gt;

&lt;h4&gt;call your java code&lt;/h4&gt;

&lt;p&gt;   你有两种方式放置你要调用的java代码，直接编译，把所有的东西放在一个文件夹里，或者使用一个jar包，总之这个自己来控制吧。下面直接假设你所有的东西都在一个叫temp.jar的java的jar包里了&lt;br/&gt;
   Jpype比较弱的一点是要你自己指定classpath, 我们假设temp.jar就在当前的文件夹下，于是classpath肯定会是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   然后我们就可以打开虚拟机了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from Jpype import *

ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
startJVM(getDefaultJVMPath(), &quot;-Djava.classpath.path=&quot;+ext_classpath)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   下面做一个假设&lt;/p&gt;

&lt;p&gt;   这个temp.jar中有一个你想要的调用的class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package trial.jpype;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import trial.jpype.CoreDataType.NameComponents;


import trial.on.jpype.shuaizki;

import me.shuaizki.util.IO.MyIO;

public class namenormalizer {

public static void speak1()
{
    System.out.println(&quot;blah..blah..blah&quot;);
}

public static String getNormalizedName(String str)
{
    NameComponents nc = NameSplit.getSingleton().getNormalizedName(str);
    return ncToJson(nc);
}

public static String ncToJson(NameComponents nc)
{
    String ret = &quot;{&quot;;
    return ret;
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们想调用的是namenormalizer中的getNormalizedName和speak1，首先要获取namenormalizer这个class，有两种途径获取这个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namenormalizer = JClass('trial.jpype.namenormalizer')
利用
ns = namenormalizer() 获取namenormlaizer 的一个对象
利用ns.getNormalizedName(“hello”)调用或者直接利用 namenormalizer.getNormalizedName()进行调用， 这样就完成了类的获取和函数的调用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种途径是利用Jpackage()这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namenormalizer = JPackage('trial').jpype.namenormalizer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   其实看看源码就会知道jpackage对类的访问依靠的也是jclass，只不过其提供了对包的访问。归根结底能找到类还是要依靠_jpype.findClass()这个函数，也就是C++代码里的东西，这个后面会有介绍。&lt;/p&gt;

&lt;h4&gt;运行代码的注意事项&lt;/h4&gt;

&lt;p&gt;   好了，我们最后的代码长成这个样子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from Jpype import *

ext_classpath = os.path.join(os.path.abspath('.'), 'temp.jar')
startJVM(getDefaultJVMPath(), &quot;-Djava.classpath.path=&quot;+ext_classpath)
namenormalizer = JClass('trial.jpype.namenormalizer')
namenormalizer.getNormalizedName(&quot;hello&quot;)

shuwdownJVM()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   尝试着运行一下吧~&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; namesplit = JClass('trial.jpype.namenormalizer')
 File &quot;/Library/Python/2.7/site-packages/jpype/_jclass.py&quot;, line 54, in JClass
raise _RUNTIMEEXCEPTION.PYEXC(&quot;Class %s not found&quot; % name)
 jpype._jexception.ExceptionPyRaisable: java.lang.Exception: Class
 trial.jpype.namenormalizer not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  纳尼！！！这是什么情况，找不到呢
  看一下我们的代码，发现没什么问题，包也在，那是为什么呢? 如果你用eclipse 的话，打开你的.classpath看看吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;classpath&amp;gt;
    &amp;lt;classpathentry kind=&quot;src&quot; path=&quot;src&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;src&quot; path=&quot;test&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.launching.macosx.MacOSXType/Java SE 6 (MacOS X Default)&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/protobuf-java-2.4.1.jar&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/gson-2.2.4.jar&quot;/&amp;gt;
    &amp;lt;classpathentry kind=&quot;output&quot; path=&quot;bin&quot;/&amp;gt;
&amp;lt;/classpath&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   如果你不用eclipse，肯定自己知道你用了一些外部包了。这些都要统统放在classpath里，不然Jpype自己是找不到的
    把这些lib里的东西都放在classpath里就行了，代码应该就能运行ok了&lt;/p&gt;

&lt;h4&gt;debug建议&lt;/h4&gt;

&lt;p&gt;如果还是跑不起来的话，那就重新编译一下JPype，让他打出debug信息，自己慢慢琢磨一下吧&lt;br/&gt;
打开src/native/common/include/jpype.h这个文件，第23行的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//#define JPYPE_TRACING_INTERNAL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  被注释掉了，将它恢复正常了吧，然后回到Jpype的目录下，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo python setup.py build -f
sudo python setup.py install -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  再运行你的代码的话，就会看到tracing信息了，剩下的就自己慢慢琢磨去吧&lt;/p&gt;

&lt;h2&gt;原理&lt;/h2&gt;

&lt;p&gt;jpype其实用的是jni实现&lt;br/&gt;
JNI就是Java Native Interface, 即可以实现Java调用本地库, 也可以实现C/C++调用Java代码, 从而实现了两种语言的互通, 可以让我们更加灵活的使用。&lt;br/&gt;
之前没听过的同学可以自行学习学习&lt;br/&gt;
利用c++完成对java调用的代码，做成python的库，这就是jpype的全部，实现全在代码里，大家自行参考喽&lt;br/&gt;
后面我会抽时间写写关于jni的博客，顺便解析一下jpype的实现&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>hadoop源码阅读-configuration</title>
   <link href="http://tom.preston-werner.com/2013/06/22/hadoop-configuration.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/06/22/hadoop-configuration</id>
   <content type="html">&lt;h1&gt;configuration&lt;/h1&gt;

&lt;p&gt;实现了Interable&amp;lt;Map.Entry&amp;lt;String, String&gt;&gt;接口和Writable接口&lt;/p&gt;

&lt;h2&gt;私有变量&lt;/h2&gt;

&lt;p&gt;比较关键的私有变量有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;Object&amp;gt; resources; 
记录各个资源文件，configuration里总共有四种形式了，String（文件名）， URL, Path(hadoop 自己定义的), 还有inputstream, 在loadresource的时候，用instanceof进行判断然后加载

Set&amp;lt;String&amp;gt; finalParameters; 记录了const的哪些配置变量（比如hdfs-site.xml里面的dfs.replication, 被设置成了final）

boolean loadDefaults = true; 用于确定是否加载默认资源(默认加载哦)

private static final WeakHashMap&amp;lt;Configuration,Object&amp;gt; REGISTRY = 
new WeakHashMap&amp;lt;Configuration,Object&amp;gt;(); 各个Conf对象的一个注册表

private static final CopyOnWriteArrayList&amp;lt;String&amp;gt; defaultResources =
new CopyOnWriteArrayList&amp;lt;String&amp;gt;(); 默认资源的一个列表, CopyOnWriteArrayList是线程安全的哦

private boolean storeResource; 是否要存储下面的hashmap

privte HashMap&amp;lt;String, String&amp;gt; updatingResource; 存储某个配置项的来源资源文件

其次是configuration里面的两个个Properties类型的变量， properties存储所有的配置项目, overlay存储所有被覆盖的配置
还有classloader变量，是当前线程的contextclassloader, 或者是当前类的classloader（如果前者为空的话）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;方法&lt;/h2&gt;

&lt;p&gt;首先用一个静态块加载了&quot;core-default.xml&quot;和&quot;core-site.xml&quot;两个资源文件&lt;/p&gt;

&lt;h3&gt;线程安全&lt;/h3&gt;

&lt;p&gt;由于configuration是线程安全的，因而注意代码里面的同步，有趣的是在configuration的一个构造函数Configuration(Configutaion other)中，看到了这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.resources = (ArrayList)other.resources.clone();
synchronized(other) {
 if (other.properties != null) {
   this.properties = (Properties)other.properties.clone();
 }

 if (other.overlay!=null) {
   this.overlay = (Properties)other.overlay.clone();
 }
}

this.finalParameters = new HashSet&amp;lt;String&amp;gt;(other.finalParameters);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让人困惑的是为什么针对resources和finalParameters的操作并没有被synchronized&lt;/p&gt;

&lt;h3&gt;资源加载相关函数&lt;/h3&gt;

&lt;p&gt;properties并非启动或者生成对象的时候加载的，而是在需要的时候才会加载，因而当有新的资源需要载入的时候，需要一个函数清理当前的properties 和 finalParameters , 这样在需要用到的时候才能重新加载.其实这个函数很简单，设置properties == null ，clear finalParameters就行了&lt;/p&gt;

&lt;h3&gt;get 和 set函数&lt;/h3&gt;

&lt;h4&gt;基本类型和enum&lt;/h4&gt;

&lt;p&gt;各种各样的get和set函数，五花八门，针对各个基本类型
都是针对properties进行操作的，由于Properties这个类本身是线程安全的，因而各种函数都是天然的线程安全函数---除了一个需要特别实现的函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private synchronized Properties getOverlay() {
if (overlay==null){
  overlay=new Properties();
}
return overlay;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }&lt;/p&gt;

&lt;h4&gt;IntegerRangs类和函数&lt;/h4&gt;

&lt;p&gt;将字符串转化为整数区间的类，目前还不清楚具体的作用是什么，只看到了一个isIncluded， 竟然是用遍历所有range来判断是否被包含在内的，感觉相当弱。。。。&lt;br/&gt;
随着这个类提供的是一个getRange函数,获取IntegerRanges结果。
值得注意的是这里的IntegerRangs使用的是静态内部类，有关静态内部类的好处看&lt;a href=&quot;http://book.51cto.com/art/201202/317517.htm&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;get class&lt;/h4&gt;

&lt;p&gt;剩下的get函数就只剩下getclass系列了&lt;br/&gt;
封装的很全面，不过实际上还是调用Class.forName(name, true, classloader)&lt;br/&gt;
有一个不错的实现之前完全没见过，就是载入实现了某个接口的类，函数如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public &amp;lt;U&amp;gt; Class&amp;lt;? extends U&amp;gt; getClass(String name, 
                                     Class&amp;lt;? extends U&amp;gt; defaultValue, 
                                     Class&amp;lt;U&amp;gt; xface) {
try {
  Class&amp;lt;?&amp;gt; theClass = getClass(name, defaultValue);
  if (theClass != null &amp;amp;&amp;amp; !xface.isAssignableFrom(theClass))
    throw new RuntimeException(theClass+&quot; not &quot;+xface.getName());
  else if (theClass != null)
    return theClass.asSubclass(xface);
  else
    return null;
} catch (Exception e) {
  throw new RuntimeException(e);
}
}
运用了isAssignableFrom函数的特性, 判断当前Class是否是theclass the superclass 或者是 superinterface(两个类相等也返回true哦)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;get resouce&lt;/h4&gt;

&lt;p&gt;核心函数是classloader.getResource&lt;/p&gt;

&lt;h4&gt;loadResource&lt;/h4&gt;

&lt;p&gt;对xml的解析用的是javax.xml.parsers&lt;br/&gt;
loadResource(Properties, Object, boolean)
是个递归函数，每次函数被调用，都会对 Element root进行赋值，然后判断root的tagname是否是configuration，如果不是的话会出直接退出，如果是，逐个对root的childnode进行解析&lt;br/&gt;
如果子节点的tag那么是configuration，调用loadresource返回上面那个步骤。否则判断子节点的tagnode是否为property（真麻烦啊。。。不过这样强有力的保障了正确性）， blah…blah…解析子节点并放在properties和finalParmeter里面&lt;/p&gt;

&lt;h5&gt;总体的感觉是封装的很标准，也有很多值得借鉴的实现。不过因为功力不够的缘故，留下了一些疑问：&lt;/h5&gt;

&lt;h5&gt;1、某些为了保证线程安全而加的synchronized段，比如上面提到的那段&lt;/h5&gt;

&lt;h5&gt;2、不同类型的classloader用起来有什么区别，比如configuration里涉及到的两种类型&lt;/h5&gt;

&lt;h5&gt;3、configuration中用到hashCode的两个函数getLocalPath和getFile&lt;/h5&gt;
</content>
 </entry>
 
 <entry>
   <title>博客动起来了</title>
   <link href="http://tom.preston-werner.com/2013/06/13/first-artical.html"/>
   <updated>2013-06-13T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/06/13/first-artical</id>
   <content type="html">&lt;h2&gt;博客动起来了&lt;/h2&gt;

&lt;p&gt;话说终于让博客动起来了。。。时隔产生这个想法n个月之后&lt;br/&gt;
不过庆幸的是这个想法最终没被忘记&lt;br/&gt;
小小得瑟一下自己跟拖延症做斗争的顽强勇气&lt;br/&gt;
以后就在这个上面写东西了, mark一下&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>本月书单</title>
   <link href="http://tom.preston-werner.com/2013/06/05/booklist-of-June.html"/>
   <updated>2013-06-05T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2013/06/05/booklist-of-June</id>
   <content type="html">&lt;h2&gt;本月书单&lt;/h2&gt;

&lt;p&gt;1、中国国民性演变历程&lt;/p&gt;

&lt;h2&gt;&lt;img src=&quot;http://img5.douban.com/lpic/s26381229.jpg&quot; alt=&quot;中国国民性演变历程&quot; /&gt;&lt;/h2&gt;

&lt;p&gt;2、Hadoop技术内幕-深入解析hadoop common和hdfs架构设计与实现原理&lt;/p&gt;

&lt;h2&gt;&lt;img src=&quot;http://img3.douban.com/lpic/s26376893.jpg&quot; alt=&quot;&quot; /&gt;&lt;/h2&gt;

&lt;p&gt;3、高效能人士的七个习惯&lt;br/&gt;
&lt;img src=&quot;http://img3.douban.com/lpic/s1152683.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>